# 数组

## 二分查找

定义左右两个端点，每次算中间值然后判断

模板: 

```java
int left,right;
while(left<=right){
    int mid=(left+right)/2;
    int mid=(right-left)/2+left;
    if(mid==target){
        return mid;
    }else if(mid<target){
        left = mid+1;
    }else{
        right = mid-1;
    }
}
```

## 原地删除元素

使用双指针，快指针向前遍历需要移动的元素或需要删除的元素，慢指针维护要移动到的下标

```java
public int removeElement(int[] nums, int val) {
    // 移除等于val的元素,使用双指针试试
    int left = 0;
    int right = 0;
    while(right<nums.length){
        if(nums[right]==val){
            right++;
        }else{
            nums[left] = nums[right];
            left++;
            right++;
        }
    }
    return left;
}
```

## 长度最小的子数组

求一个数组中，和大于等于s的连续子数组的最小长度，数组元素和s均为正整数

使用双指针法，如果数组元素为字符或者数组元素需要分类等题目，可以引入哈希表来进行辅助

模板:

```java
public int minSubArrayLen(int target, int[] nums) {
    int l=0;
    int r=0;
    int sum=0;
    int min=Integer.MAX_VALUE;
    //右指针始终向右移动,和>=s了则记录长度(左右指针的差值),然后左指针移动
    while(r<nums.length){
        if(sum<target) sum+=nums[r++];
        // 大于目标值了,左指针要移动到小于目标值才可
        while(sum>=target){
            min = Math.min(min,r-l);
            sum-=nums[l++];
        }
    }
    if(min==Integer.MAX_VALUE) min=0;
    return min;
}
```

## 螺旋矩阵

对一个二维数组进行螺旋输入或输出时，需要注意四个边界的设置

模板：将1-n^2的数字按转圈的形式写入二维数组

```java
public int[][] generateMatrix(int n) {
    int[][] result = new int[n][n];
    int w = 1;
    int maxI=n-1,maxJ=n-1,minI=0,minJ=0;
    while(true){
        // 向右移动,上限下移
        for(int j=minJ;j<=maxJ;j++) result[minI][j] = w++;
        if(minI++>=maxI) break;
        // 向下移动,右限左移
        for(int i=minI;i<=maxI;i++) result[i][maxJ] = w++;
        if(maxJ--<=minJ) break;
        // 向左移动,下限上移
        for(int j=maxJ;j>=minJ;j--) result[maxI][j] = w++;
        if(maxI--<=minI) break;
        // 向上移动,左限右移
        for(int i=maxI;i>=minI;i--) result[i][minJ] = w++;
        if(minJ++>=maxJ) break;
    }
    return result;
}
```

# 链表

## 移除链表元素

有两种方式可以移除链表元素，一种是直接移除，对于头结点特殊处理，另一种是设置哑结点在头结点之前，将头结点视为普通节点去操作。

```java
public ListNode removeElements(ListNode head, int val) {
    // 哑节点
    ListNode preHead = new ListNode(0,head);
    // 前节点
    ListNode pre = preHead;
    // 当前节点
    while(head!=null){
        if(head.val==val){
            pre.next = head.next;
        }else{
            pre = pre.next;  
        }
        head = head.next;
    }
    return preHead.next;
}
```

## 设计链表

针对链表的经典增删改查方法进行设计

```shell
// 单一结点
class Node{
    int val;
    Node next;
    Node pre;

    public Node(int val, Node next, Node pre){
        this.val = val;
        this.next = next;
        this.pre = pre;
    }

    public Node(int val){
        this.val = val;
    }

    public Node(){}
}

// 链表对象
class MyLinkedList {
    Node preHead;
    Node lastTail;
    int size;
    
    public MyLinkedList() {
        this.preHead = new Node();
        this.lastTail = new Node();
        preHead.next = lastTail;
        lastTail.pre = preHead;
    }
    
    // 根据下标获取元素
    public int get(int index) {
        Node result = getNode(index);
        if(result!=null){
            return result.val;
        }else{
            return -1;
        }
    }

    public Node getNode(int index) {
        // 下标不合法
        if(index<0 || index>=size) {return null;}
        int i=0;
        Node now = preHead.next;
        while(i<index){
            if(now == lastTail) {return null;}
            i++;now = now.next;
        }
        if(now == lastTail) {return null;}
        return now;
    }
    
    // 头部插入
    public void addAtHead(int val) {
        Node newNode = new Node(val);
        newNode.next = preHead.next;
        newNode.pre = preHead;
        preHead.next.pre = newNode;
        preHead.next = newNode;
        size++;
    }
    
    // 尾部插入
    public void addAtTail(int val) {
        Node newNode = new Node(val);
        newNode.next = lastTail;
        newNode.pre = lastTail.pre;
        lastTail.pre.next = newNode;
        lastTail.pre = newNode;
        size++;
    }
    
    // 按位置插入
    public void addAtIndex(int index, int val) {
        // 下标等于长度,尾部插入
        if(index==size) {addAtTail(val);return;}
        Node node = getNode(index);
        if(node != null){
            Node newNode = new Node(val);
            newNode.next = node;
            newNode.pre = node.pre;
            node.pre.next = newNode;
            node.pre = newNode;
            size++;
        }
    }
    
    // 按位置删除
    public void deleteAtIndex(int index) {
        Node node = getNode(index);
        if(node != null){
            node.pre.next = node.next;
            node.next.pre = node.pre;
            size--;
        }
    }
}
```

## 翻转链表

将链表进行反向，遍历整个链表的同时用一个临时变量存储下一个节点

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode left = head;
        ListNode right = head.next;
        ListNode temp;
        head.next = null;
        while(right!=null){
            temp = right.next;
            right.next = left;
            left = right;
            right = temp;
        }
        return left;
    }
}
```

## 两两交换链表中的节点

使用哑节点来处理头结点

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        // 创建哑节点
        ListNode ya = new ListNode();
        ya.next = head;
        // 前置节点,方便换位
        ListNode pre = ya;

        // 前置节点后有两个不为空的节点(可以交换)
        while(!(pre.next == null || pre.next.next == null)){
            exchange(pre, pre.next, pre.next.next);
            // 前置节点移动
            pre = pre.next.next;
        }
        // 返回整个链表
        return ya.next;
    }

    public void exchange(ListNode pre, ListNode n1, ListNode n2){
        // 交换操作
        pre.next = n2;
        n1.next = n2.next;
        n2.next = n1;
    }
}
```

## 删除链表的倒数第n个节点

使用快慢指针法，快指针先移动n次，然后再同时移动到快指针到末尾时，这时慢指针指向的则是要删除的位置

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    // 删除倒数第n个节点
    ListNode preHead = new ListNode(-1,head);
    // fast先向后移动n次,slow指向要删除的节点的前一个
    ListNode fast=head,slow=preHead;
    // fast先向后移动n次
    while(n>0){fast = fast.next;n--;}
    // fast移动到末尾时,slow指向的正是要删除的元素的前一个
    while(fast!=null){
        fast = fast.next;
        slow = slow.next;
    }
    // 移除该元素
    slow.next = slow.next.next;
    // 返回结果
    return preHead.next;
}
```

## 判断两个链表是否交叉

使用双指针思想，同时遍历两个链表，一个遍历完则转到另一条链上，最后要么相交要么同时到末尾

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    ListNode pa=headA,pb=headB;
    // 初始头节点就是空,返回空
    if(headA==null || headB==null){return null;}
    // 开始循环遍历
    while(true){
        // 两个节点重合了,返回节点
        if(pa==pb){return pa;}
        // 节点向后移动
        pa = pa.next;
        pb = pb.next;
        // a,b同时移动到末尾说明没有交点
        if(pa==null && pb==null){return null;}
        // 其中一者移动到末尾,则转移到对方的链表上
        if(pa==null){pa = headB;}
        if(pb==null){pb = headA;}
    }
}
```

## 环形链表

https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF

找到一个链表是否有环，若有环则找到环的起点

思路：快慢指针可以找到是否有环，若两个指针相遇则有环，若快指针先为空则无环

找到环之后从头节点和快慢指针相遇的点同时发出两个指针，两个指针相遇时，就是环的起点。

![image-20240229115135453](%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95.assets/image-20240229115135453.png)

快慢指着同时出发，相遇时：

快指针移动了x+n*(y+z)+y的距离，

慢指针移动了x+y的距离

同时快指针移动的距离是慢指针的两倍

可得: 2\*(x+y)=x+y+n\*(y+z)

x+y=n*(y+z)

x = (n-1)*(y+z)+z

当n=1时，x = z

```java
public ListNode detectCycle(ListNode head) {
    ListNode fast = head;
    ListNode slow = head;
    // 快指针移动两次,慢指针移动一次
    while(fast!=null && fast.next!=null && fast.next.next!=null){
        fast = fast.next.next;
        slow = slow.next;
        // 如果相遇了
        if(fast==slow){
            // 相遇点和头结点同时出发两个指针,他们两个相遇的地方则是环的起点
            ListNode index1=head,index2=slow;
            while(index1!=index2){
                index1 = index1.next;
                index2 = index2.next;
            }
            return index1;
        }
    }
    return null;
}
```

# 哈希表

## 有效的字母异位词

给定两个单词，判断这两个单词是不是字母异位词(每一个字母出现的次数都一致)

```java
public boolean isAnagram(String s, String t) {
    // 长度相同再进行判断,先全部加上,再全部减去
    // if(s.length()==t.length()){
    //     int[] sc = new int[26];
    //     for(int i=0;i<s.length();i++){
    //         sc[s.charAt(i)-'a']++;
    //         sc[t.charAt(i)-'a']--;
    //     }
    //     for(int c:sc){
    //         if(c!=0){return false;}
    //     }
    //     return true;
    // }
    // return false;
    // 改进思路: 先全部加上,在减的时候其中一个小于0了则说明肯定不符合了
    if(s.length()!=t.length()) return false;
    int[] sc = new int[26];
    for(int i=0;i<s.length();i++){
        sc[s.charAt(i)-'a']++;
    }
    for(int i=0;i<t.length();i++){
        sc[t.charAt(i)-'a']--;
        if(sc[t.charAt(i)-'a']<0) return false;
    }
    return true;
}
```

## 两个数组的交集

给出两个数组，将同时出现在两个数组中的数字输出，只输出一次，不限制顺序

思路: 使用一个大数组作为哈希表进行运算

```java
public int[] intersection(int[] nums1, int[] nums2) {
    // 因为给出了数字的取值范围,所以可以定义一个大数组作为哈希表
    int[] hash = new int[1002];
    // 存储结果
    List<Integer> result = new ArrayList<>();
    // nums1中出现的记录为1
    for(int i:nums1){
        hash[i] = 1;
    }
    // 同时出现的记录为2并放入结果列表
    for(int i:nums2){
        if(hash[i]==1){
            hash[i]++;
            result.add(i);
        }
    }
    // 遍历结果列表生成数组
    int[] r = new int[result.size()];
    int index=0;
    for(int i:result){
        r[index++] = i;
    } 
    return r;
}
```

## 快乐数

一个数，每次计算将他变成他每个位数字的平方和，若这个数字经过有限次的运算可以变成1，则是快乐数，否则会陷入循环，不是快乐数。

```java
public boolean isHappy(int n) {
    // 快慢指针法,若陷入死循环则快指针和慢指针会重合,否则快指针会先算到1
    int fast = n;
    int slow = n;
    // 快慢指针
    while(true){
        fast = calc(calc(fast));
        slow = calc(slow);
        if(fast==1) return true;
        if(fast==slow) return false;
    }
}

// 计算平方和
public int calc(int num){
    int r=0;
    while(num>0){
        r+=(num%10)*(num%10);
        num = num/10;
    }
    return r;
}
```

## 两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

```java
public int[] twoSum(int[] nums, int target) {
    // 两数之和，哈希表的键为【目标-数组中当前位】值为【数组中当前下标】
    Map<Integer, Integer> map = new HashMap<>();
    for(int i=0;i<nums.length;i++){
        int value = nums[i];
        // 如果存在键,则返回
        if(map.containsKey(value)){
            return new int[]{i, map.get(value)};
        }else{
            // 否则入哈希表
            map.put(target-value, i);
        }
    }
    return null;
}
```

## [四数相加II](https://leetcode.cn/problems/4sum-ii/)

给定四个数组，四个数组中各出一个数字，求相加之和为0的组合有多少次

思路：先遍历前两个数组，将不同结果出现的次数记录在哈希表中，再遍历后两个数组，0-后两个数组中值的和若是哈希表的键，说明这种情况下可以计算的0，将哈希表的值（出现的次数）加到结果中。

将数组作为哈希表可以提升速度

```java
public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
    // 思路: 先遍历ab,再遍历cd
    Map<Integer, Integer> map = new HashMap<>();
    for(int i:nums1){
        for(int j:nums2){
            // 将两者之和出现的次数记录在哈希表中
            map.put(i+j,map.getOrDefault(i+j,0)+1);
        }
    }
    int r=0;
    for(int i:nums3){
        for(int j:nums4){
            // 若0-i-j在哈希表中说明结果为0
            if(map.containsKey(0-i-j)){
                r+=map.get(0-i-j);
            }
        }
    }
    return r;
}
```


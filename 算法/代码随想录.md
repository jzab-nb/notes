# 数组

## 二分查找

定义左右两个端点，每次算中间值然后判断

模板: 

```java
int left,right;
while(left<=right){
    int mid=(left+right)/2;
    int mid=(right-left)/2+left;
    if(mid==target){
        return mid;
    }else if(mid<target){
        left = mid+1;
    }else{
        right = mid-1;
    }
}
```

## 原地删除元素

使用双指针，快指针向前遍历需要移动的元素或需要删除的元素，慢指针维护要移动到的下标

```java
public int removeElement(int[] nums, int val) {
    // 移除等于val的元素,使用双指针试试
    int left = 0;
    int right = 0;
    while(right<nums.length){
        if(nums[right]==val){
            right++;
        }else{
            nums[left] = nums[right];
            left++;
            right++;
        }
    }
    return left;
}
```

## 长度最小的子数组

求一个数组中，和大于等于s的连续子数组的最小长度，数组元素和s均为正整数

使用双指针法，如果数组元素为字符或者数组元素需要分类等题目，可以引入哈希表来进行辅助

模板:

```java
public int minSubArrayLen(int target, int[] nums) {
    int l=0;
    int r=0;
    int sum=0;
    int min=Integer.MAX_VALUE;
    //右指针始终向右移动,和>=s了则记录长度(左右指针的差值),然后左指针移动
    while(r<nums.length){
        if(sum<target) sum+=nums[r++];
        // 大于目标值了,左指针要移动到小于目标值才可
        while(sum>=target){
            min = Math.min(min,r-l);
            sum-=nums[l++];
        }
    }
    if(min==Integer.MAX_VALUE) min=0;
    return min;
}
```

## 螺旋矩阵

对一个二维数组进行螺旋输入或输出时，需要注意四个边界的设置

模板：将1-n^2的数字按转圈的形式写入二维数组

```java
public int[][] generateMatrix(int n) {
    int[][] result = new int[n][n];
    int w = 1;
    int maxI=n-1,maxJ=n-1,minI=0,minJ=0;
    while(true){
        // 向右移动,上限下移
        for(int j=minJ;j<=maxJ;j++) result[minI][j] = w++;
        if(minI++>=maxI) break;
        // 向下移动,右限左移
        for(int i=minI;i<=maxI;i++) result[i][maxJ] = w++;
        if(maxJ--<=minJ) break;
        // 向左移动,下限上移
        for(int j=maxJ;j>=minJ;j--) result[maxI][j] = w++;
        if(maxI--<=minI) break;
        // 向上移动,左限右移
        for(int i=maxI;i>=minI;i--) result[i][minJ] = w++;
        if(minJ++>=maxJ) break;
    }
    return result;
}
```

# 链表

## 移除链表元素

有两种方式可以移除链表元素，一种是直接移除，对于头结点特殊处理，另一种是设置哑结点在头结点之前，将头结点视为普通节点去操作。

```java
public ListNode removeElements(ListNode head, int val) {
    // 哑节点
    ListNode preHead = new ListNode(0,head);
    // 前节点
    ListNode pre = preHead;
    // 当前节点
    while(head!=null){
        if(head.val==val){
            pre.next = head.next;
        }else{
            pre = pre.next;  
        }
        head = head.next;
    }
    return preHead.next;
}
```

## 设计链表

针对链表的经典增删改查方法进行设计

```shell
// 单一结点
class Node{
    int val;
    Node next;
    Node pre;

    public Node(int val, Node next, Node pre){
        this.val = val;
        this.next = next;
        this.pre = pre;
    }

    public Node(int val){
        this.val = val;
    }

    public Node(){}
}

// 链表对象
class MyLinkedList {
    Node preHead;
    Node lastTail;
    int size;
    
    public MyLinkedList() {
        this.preHead = new Node();
        this.lastTail = new Node();
        preHead.next = lastTail;
        lastTail.pre = preHead;
    }
    
    // 根据下标获取元素
    public int get(int index) {
        Node result = getNode(index);
        if(result!=null){
            return result.val;
        }else{
            return -1;
        }
    }

    public Node getNode(int index) {
        // 下标不合法
        if(index<0 || index>=size) {return null;}
        int i=0;
        Node now = preHead.next;
        while(i<index){
            if(now == lastTail) {return null;}
            i++;now = now.next;
        }
        if(now == lastTail) {return null;}
        return now;
    }
    
    // 头部插入
    public void addAtHead(int val) {
        Node newNode = new Node(val);
        newNode.next = preHead.next;
        newNode.pre = preHead;
        preHead.next.pre = newNode;
        preHead.next = newNode;
        size++;
    }
    
    // 尾部插入
    public void addAtTail(int val) {
        Node newNode = new Node(val);
        newNode.next = lastTail;
        newNode.pre = lastTail.pre;
        lastTail.pre.next = newNode;
        lastTail.pre = newNode;
        size++;
    }
    
    // 按位置插入
    public void addAtIndex(int index, int val) {
        // 下标等于长度,尾部插入
        if(index==size) {addAtTail(val);return;}
        Node node = getNode(index);
        if(node != null){
            Node newNode = new Node(val);
            newNode.next = node;
            newNode.pre = node.pre;
            node.pre.next = newNode;
            node.pre = newNode;
            size++;
        }
    }
    
    // 按位置删除
    public void deleteAtIndex(int index) {
        Node node = getNode(index);
        if(node != null){
            node.pre.next = node.next;
            node.next.pre = node.pre;
            size--;
        }
    }
}
```


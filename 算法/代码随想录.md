## 数组

### 二分查找

定义左右两个端点，每次算中间值然后判断

模板: 

```java
int left,right;
while(left<=right){
    int mid=(left+right)/2;
    int mid=(right-left)/2+left;
    if(mid==target){
        return mid;
    }else if(mid<target){
        left = mid+1;
    }else{
        right = mid-1;
    }
}
```

### 原地删除元素

使用双指针，快指针向前遍历需要移动的元素或需要删除的元素，慢指针维护要移动到的下标

```java
public int removeElement(int[] nums, int val) {
    // 移除等于val的元素,使用双指针试试
    int left = 0;
    int right = 0;
    while(right<nums.length){
        if(nums[right]==val){
            right++;
        }else{
            nums[left] = nums[right];
            left++;
            right++;
        }
    }
    return left;
}

public int removeElement(int[] nums, int val) {
    int i=0;
    for(int k=0;k<nums.length;k++){
        // 不等于val则赋值,等于则只移动右指针
        if(nums[k]!=val) nums[i++] = nums[k];
    }
    return i;
}
```

### 长度最小的子数组

求一个数组中，和大于等于s的连续子数组的最小长度，数组元素和s均为正整数

使用双指针法，如果数组元素为字符或者数组元素需要分类等题目，可以引入哈希表来进行辅助

模板:

```java
public int minSubArrayLen(int target, int[] nums) {
    int l=0;
    int r=0;
    int sum=0;
    int min=Integer.MAX_VALUE;
    //右指针始终向右移动,和>=s了则记录长度(左右指针的差值),然后左指针移动
    while(r<nums.length){
        if(sum<target) sum+=nums[r++];
        // 大于目标值了,左指针要移动到小于目标值才可
        while(sum>=target){
            min = Math.min(min,r-l);
            sum-=nums[l++];
        }
    }
    if(min==Integer.MAX_VALUE) min=0;
    return min;
}
```

### 螺旋矩阵

对一个二维数组进行螺旋输入或输出时，需要注意四个边界的设置

模板：将1-n^2的数字按转圈的形式写入二维数组

```java
public int[][] generateMatrix(int n) {
    int[][] result = new int[n][n];
    int w = 1;
    int maxI=n-1,maxJ=n-1,minI=0,minJ=0;
    while(true){
        // 向右移动,上限下移
        for(int j=minJ;j<=maxJ;j++) result[minI][j] = w++;
        if(minI++>=maxI) break;
        // 向下移动,右限左移
        for(int i=minI;i<=maxI;i++) result[i][maxJ] = w++;
        if(maxJ--<=minJ) break;
        // 向左移动,下限上移
        for(int j=maxJ;j>=minJ;j--) result[maxI][j] = w++;
        if(maxI--<=minI) break;
        // 向上移动,左限右移
        for(int i=maxI;i>=minI;i--) result[i][minJ] = w++;
        if(minJ++>=maxJ) break;
    }
    return result;
}
```

## 链表

### 移除链表元素

有两种方式可以移除链表元素，一种是直接移除，对于头结点特殊处理，另一种是设置哑结点在头结点之前，将头结点视为普通节点去操作。

```java
public ListNode removeElements(ListNode head, int val) {
    // 哑节点
    ListNode preHead = new ListNode(0,head);
    // 前节点
    ListNode pre = preHead;
    // 当前节点
    while(head!=null){
        if(head.val==val){
            pre.next = head.next;
        }else{
            pre = pre.next;  
        }
        head = head.next;
    }
    return preHead.next;
}
```

### 设计链表

针对链表的经典增删改查方法进行设计

```shell
// 单一结点
class Node{
    int val;
    Node next;
    Node pre;

    public Node(int val, Node next, Node pre){
        this.val = val;
        this.next = next;
        this.pre = pre;
    }

    public Node(int val){
        this.val = val;
    }

    public Node(){}
}

// 链表对象
class MyLinkedList {
    Node preHead;
    Node lastTail;
    int size;
    
    public MyLinkedList() {
        this.preHead = new Node();
        this.lastTail = new Node();
        preHead.next = lastTail;
        lastTail.pre = preHead;
    }
    
    // 根据下标获取元素
    public int get(int index) {
        Node result = getNode(index);
        if(result!=null){
            return result.val;
        }else{
            return -1;
        }
    }

    public Node getNode(int index) {
        // 下标不合法
        if(index<0 || index>=size) {return null;}
        int i=0;
        Node now = preHead.next;
        while(i<index){
            if(now == lastTail) {return null;}
            i++;now = now.next;
        }
        if(now == lastTail) {return null;}
        return now;
    }
    
    // 头部插入
    public void addAtHead(int val) {
        Node newNode = new Node(val);
        newNode.next = preHead.next;
        newNode.pre = preHead;
        preHead.next.pre = newNode;
        preHead.next = newNode;
        size++;
    }
    
    // 尾部插入
    public void addAtTail(int val) {
        Node newNode = new Node(val);
        newNode.next = lastTail;
        newNode.pre = lastTail.pre;
        lastTail.pre.next = newNode;
        lastTail.pre = newNode;
        size++;
    }
    
    // 按位置插入
    public void addAtIndex(int index, int val) {
        // 下标等于长度,尾部插入
        if(index==size) {addAtTail(val);return;}
        Node node = getNode(index);
        if(node != null){
            Node newNode = new Node(val);
            newNode.next = node;
            newNode.pre = node.pre;
            node.pre.next = newNode;
            node.pre = newNode;
            size++;
        }
    }
    
    // 按位置删除
    public void deleteAtIndex(int index) {
        Node node = getNode(index);
        if(node != null){
            node.pre.next = node.next;
            node.next.pre = node.pre;
            size--;
        }
    }
}
```

### 翻转链表

将链表进行反向，遍历整个链表的同时用一个临时变量存储下一个节点

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode left = head;
        ListNode right = head.next;
        ListNode temp;
        head.next = null;
        while(right!=null){
            temp = right.next;
            right.next = left;
            left = right;
            right = temp;
        }
        return left;
    }
    // 三指针
    public ListNode reverseList(ListNode head) {
    	if(head==null || head.next==null) return head;
        ListNode l1=null,l2=head,l3=head.next;
        while(true){
            l2.next = l1;
            if(l3==null) return l2;
            l1 = l2; l2 = l3;
            l3 = l3.next;
        }
    }
}
```

### 两两交换链表中的节点

使用哑节点来处理头结点

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        // 创建哑节点
        ListNode ya = new ListNode();
        ya.next = head;
        // 前置节点,方便换位
        ListNode pre = ya;

        // 前置节点后有两个不为空的节点(可以交换)
        while(!(pre.next == null || pre.next.next == null)){
            exchange(pre, pre.next, pre.next.next);
            // 前置节点移动
            pre = pre.next.next;
        }
        // 返回整个链表
        return ya.next;
    }

    public void exchange(ListNode pre, ListNode n1, ListNode n2){
        // 交换操作
        pre.next = n2;
        n1.next = n2.next;
        n2.next = n1;
    }
}
```

### 删除链表的倒数第n个节点

使用快慢指针法，快指针先移动n次，然后再同时移动到快指针到末尾时，这时慢指针指向的则是要删除的位置

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    // 删除倒数第n个节点
    ListNode preHead = new ListNode(-1,head);
    // fast先向后移动n次,slow指向要删除的节点的前一个
    ListNode fast=head,slow=preHead;
    // fast先向后移动n次
    while(n>0){fast = fast.next;n--;}
    // fast移动到末尾时,slow指向的正是要删除的元素的前一个
    while(fast!=null){
        fast = fast.next;
        slow = slow.next;
    }
    // 移除该元素
    slow.next = slow.next.next;
    // 返回结果
    return preHead.next;
}
```

### 判断两个链表是否交叉

使用双指针思想，同时遍历两个链表，一个遍历完则转到另一条链上，最后要么相交要么同时到末尾

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    ListNode pa=headA,pb=headB;
    // 初始头节点就是空,返回空
    if(headA==null || headB==null){return null;}
    // 开始循环遍历
    while(true){
        // 两个节点重合了,返回节点
        if(pa==pb){return pa;}
        // 节点向后移动
        pa = pa.next;
        pb = pb.next;
        // a,b同时移动到末尾说明没有交点
        if(pa==null && pb==null){return null;}
        // 其中一者移动到末尾,则转移到对方的链表上
        if(pa==null){pa = headB;}
        if(pb==null){pb = headA;}
    }
}
```

### 环形链表二

https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html##%E6%80%9D%E8%B7%AF

找到一个链表是否有环，若有环则找到环的起点

思路：快慢指针可以找到是否有环，若两个指针相遇则有环，若快指针先为空则无环

找到环之后从头节点和快慢指针相遇的点同时发出两个指针，两个指针相遇时，就是环的起点。

![image-20240229115135453](%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95.assets/image-20240229115135453.png)

快慢指着同时出发，相遇时：

快指针移动了x+n*(y+z)+y的距离，

慢指针移动了x+y的距离

同时快指针移动的距离是慢指针的两倍

可得: 2\*(x+y)=x+y+n\*(y+z)

x+y=n*(y+z)

x = (n-1)*(y+z)+z

当n=1时，x = z

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        // 快指针移动两次,慢指针移动一次
        ListNode fast=head,slow=head;
        while(fast!=null && fast.next!=null && fast.next.next!=null){
            fast = fast.next.next;
            slow = slow.next;
            // 如果相遇了
        	if(fast==slow){
            	// 相遇点和头结点同时出发两个指针,他们两个相遇的地方则是环的起点
                while(head!=slow){
                    slow = slow.next;
                    head = head.next;
                }
                return head;
            }
        }
        return null;
    }
}
```

## 哈希表

### 有效的字母异位词

给定两个单词，判断这两个单词是不是字母异位词(每一个字母出现的次数都一致)

```java
public boolean isAnagram(String s, String t) {
    // 长度相同再进行判断,先全部加上,再全部减去
    // if(s.length()==t.length()){
    //     int[] sc = new int[26];
    //     for(int i=0;i<s.length();i++){
    //         sc[s.charAt(i)-'a']++;
    //         sc[t.charAt(i)-'a']--;
    //     }
    //     for(int c:sc){
    //         if(c!=0){return false;}
    //     }
    //     return true;
    // }
    // return false;
    // 改进思路: 先全部加上,在减的时候其中一个小于0了则说明肯定不符合了
    if(s.length()!=t.length()) return false;
    int[] sc = new int[26];
    for(int i=0;i<s.length();i++){
        sc[s.charAt(i)-'a']++;
    }
    for(int i=0;i<t.length();i++){
        sc[t.charAt(i)-'a']--;
        if(sc[t.charAt(i)-'a']<0) return false;
    }
    return true;
}
```

### 两个数组的交集

给出两个数组，将同时出现在两个数组中的数字输出，只输出一次，不限制顺序

思路: 使用一个大数组作为哈希表进行运算

```java
public int[] intersection(int[] nums1, int[] nums2) {
    // 因为给出了数字的取值范围,所以可以定义一个大数组作为哈希表
    int[] hash = new int[1002];
    // 存储结果
    List<Integer> result = new ArrayList<>();
    // nums1中出现的记录为1
    for(int i:nums1){
        hash[i] = 1;
    }
    // 同时出现的记录为2并放入结果列表
    for(int i:nums2){
        if(hash[i]==1){
            hash[i]++;
            result.add(i);
        }
    }
    // 遍历结果列表生成数组
    int[] r = new int[result.size()];
    int index=0;
    for(int i:result){
        r[index++] = i;
    } 
    return r;
}
```

### 快乐数

一个数，每次计算将他变成他每个位数字的平方和，若这个数字经过有限次的运算可以变成1，则是快乐数，否则会陷入循环，不是快乐数。

```java
public boolean isHappy(int n) {
    // 快慢指针法,若陷入死循环则快指针和慢指针会重合,否则快指针会先算到1
    int fast = n;
    int slow = n;
    // 快慢指针
    while(true){
        fast = calc(calc(fast));
        slow = calc(slow);
        if(fast==1) return true;
        if(fast==slow) return false;
    }
}

// 计算平方和
public int calc(int num){
    int r=0;
    while(num>0){
        r+=(num%10)*(num%10);
        num = num/10;
    }
    return r;
}
```

### 两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

```java
public int[] twoSum(int[] nums, int target) {
    // 两数之和，哈希表的键为【目标-数组中当前位】值为【数组中当前下标】
    Map<Integer, Integer> map = new HashMap<>();
    for(int i=0;i<nums.length;i++){
        int value = nums[i];
        // 如果存在键,则返回
        if(map.containsKey(value)){
            return new int[]{i, map.get(value)};
        }else{
            // 否则入哈希表
            map.put(target-value, i);
        }
    }
    return null;
}
```

### [四数相加II](https://leetcode.cn/problems/4sum-ii/)

给定四个数组，四个数组中各出一个数字，求相加之和为0的组合有多少次

思路：先遍历前两个数组，将不同结果出现的次数记录在哈希表中，再遍历后两个数组，0-后两个数组中值的和若是哈希表的键，说明这种情况下可以计算的0，将哈希表的值（出现的次数）加到结果中。

将数组作为哈希表可以提升速度

```java
public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
    // 思路: 先遍历ab,再遍历cd
    Map<Integer, Integer> map = new HashMap<>();
    for(int i:nums1){
        for(int j:nums2){
            // 将两者之和出现的次数记录在哈希表中
            map.put(i+j,map.getOrDefault(i+j,0)+1);
        }
    }
    int r=0;
    for(int i:nums3){
        for(int j:nums4){
            // 若0-i-j在哈希表中说明结果为0
            if(map.containsKey(0-i-j)){
                r+=map.get(0-i-j);
            }
        }
    }
    return r;
}
```

### 赎金信

有字符串a,b,要求a中各个字母出现的次数小于等于b中出现的次数

思路: 先遍历B,这样在遍历a的时候遇到b大于a的情况可以提前结束循环,节省时间

```java
public boolean canConstruct(String ransomNote, String magazine) {
    // a中的字符的出现次数要小于等于b中字符的出现次数
    int[] arr = new int[26];
    for(int i=0;i<magazine.length();i++) arr[magazine.charAt(i)-'a']++;
    for(int i=0;i<ransomNote.length();i++){
        if(--arr[ransomNote.charAt(i)-'a']<0) return false;
    }
    return true;
}
```

### 三数之和

给定一个数组，要求数组中三个数相加之和为0的所有情况，返回值的三元组。三元组不许重复

思路：先对数组进行排序，然后外层遍历三元组的第一个数，内层双指针寻找第2，3个数，外层去重判断当前数是否等于他的上一个，内层当结果为0时再对左右指针进行循环去重。

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        // 排序+双指针
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            if(i>0 && nums[i-1]==nums[i]) continue;
            // 遍历的是三元组中的第一个元素
            // 双指针指向三元组第2,3个元素
            // 结果比0大,右指针左移,比0小左指针右移,否则同时移动左右指针
            int left = i+1;
            int right = nums.length-1;
            
            while(left<right){
                int tmp = nums[i]+nums[left]+nums[right];
                if(tmp<0){
                    left++;
                }else if(tmp>0){
                    right--;
                }else{
                    List<Integer> line = new ArrayList<>();
                    result.add(line);
                    line.add(nums[i]);
                    line.add(nums[left]);
                    line.add(nums[right]);
                    // 去除重复值
                    while(left < right && nums[left] == nums[left+1]) left++;
                    while(left < right && nums[right] == nums[right-1]) right--;
                    left++;right--;
                }
            }
        }
        return result;
    }
}
```

### 四数之和

与三数之和相同，再多加一层循环

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        // 四数之和,两层循环,一层双指针
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        for(int i=0;i<nums.length;i++){
            // 第一个元素重复，跳过
            if(i>0 && nums[i]==nums[i-1]) continue;
            for(int j=i+1;j<nums.length;j++){
                // 第二个元素重复，跳过
                if(j>i+1 && nums[j]==nums[j-1]) continue;
                // 定义两个指针
                int left=j+1,right=nums.length-1;
                while(left<right){
                    long tmp = (long)nums[i]+nums[j]+nums[left]+nums[right];
                    // 左指针右移,结果变大
                    if(tmp<target){
                        left++;
                    // 右指针左移,结果变小
                    }else if(tmp>target){
                        right--;
                    }else{
                        List<Integer> line = new ArrayList<>();
                        result.add(line);
                        line.add(nums[left]);line.add(nums[right]);line.add(nums[i]);line.add(nums[j]);
                        // 去除重复的left和right
                        while(left<right && nums[left+1] == nums[left]) left++;
                        while(left<right && nums[right-1] == nums[right]) right--;
                        left++;right--;
                    }
                }
            }
        }
        return result;
    }
}
```

## 字符串

### 反转字符串

原地修改将字符数组反转

思路: 双指针法

```java
class Solution {
    public void reverseString(char[] s) {
        int l=0,r=s.length-1;
        char tmp;
        while(l<r){
            tmp = s[l];
            s[l] = s[r];
            s[r] = tmp;
            l++;r--;
        }
    }
}

// 可以用异或方式实现交换操作
public void reverseString(char[] s) {
    for(int i=0,j=s.length-1;i<j;i++,j--) s[i] ^= s[j]; s[j] ^= s[i]; s[i] ^= s[j];
    // a b
    // a^b b
    // a^b a
    // b a
}
```

### 反转字符串2

给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

```java
class Solution {
    public String reverseStr(String s, int k) {
        char[] sc = s.toCharArray();
        // i每次移动2k
        for(int i=0;i<s.length();i+=2*k){
            // i作为左指针,右指针可能为i+k,或者结尾部分
            exchange(sc,i,Math.min(i+k-1,s.length()-1));
        }
        return new String(sc);
    }

    public void exchange(char[] sc,int left,int right) {
        // 交换
        while(left<right){
            char temp = sc[left];
            sc[left] = sc[right];
            sc[right] = temp;
            left++;right--;
        }
    }
}
```

### 替换数字

将字符串中出现的数字替换成number再输出

思路: 一次遍历，使用StringBuilder实现

```java
Scanner in = new Scanner(System.in);
String s = in.next();
StringBuilder sb = new StringBuilder();
for(int i=0;i<s.length();i++){
    char c = s.charAt(i);
    if(c>='0' && c<='9') sb.append("number");
    else sb.append(c);
}
System.out.println(sb);
```

### 翻转字符串里的单词

将字符串中多余的空格去掉，单词出现的顺序反转但单词内部顺序不变

思路：先整体反转，再反转单词内部

```java
public String reverseWords(String s) {
    boolean word = false;
    List<String> result = new ArrayList<>();
    StringBuilder sb = new StringBuilder();
    for(int i=0;i<=s.length();i++){
        // 上一个字符是单词,当前是空格,或者到末尾
        if(word &&(i==s.length() || s.charAt(i) == ' ')){
            result.add(sb.toString());
            sb = new StringBuilder();
            word = !word;
            continue;
        }
        if(i==s.length()) break;
        if(!word && s.charAt(i) != ' '){
            word = !word;
        }
        if(word) sb.append(s.charAt(i));
    }
    sb = new StringBuilder();
    for(int i=result.size()-1;i>=0;i--){
        sb.append(result.get(i));
        if(i!=0) sb.append(" ");
    }
    return sb.toString();
}

class Solution {
    public String reverseWords(String s) {
        // 先去除空格,再整体翻转,再翻转各个单词
        char[] sb = removeBlank(s);
        reverse(sb,0,sb.length-1);
        for(int i=0,j=0;j<sb.length;j++){
            // System.out.printf("%d,%d\n",i,j);
            if(j==sb.length-1 || sb[j+1]==' '){
                reverse(sb,i,j);
                i = j+2;
            }
            
        }
        return new String(sb);
    }

    // 去除空格
    public char[] removeBlank(String s){
        // 双指针法去除多余的空格
        char[] sc = s.toCharArray();
        int i=0;
        for(int j=0;j<sc.length;j++){
            // 什么情况下需要移动j位置的字符到i位置: 1.j不为空格 2.j为一串空格中的最后一个(不包含开头的空格)
            if(sc[j]!=' ' || (sc[j] == ' ' && i!=0 && j<sc.length-1 && sc[j+1] != ' ')) sc[i++] = sc[j];
        }
        char[] newChars = new char[i];
        System.arraycopy(sc,0,newChars,0,i);
        return newChars;
    }

    // 翻转部分字符串
    public void reverse(char[] sb, int start, int end){
        while(start<end){
            sb[start] ^= sb[end];
            sb[end] ^= sb[start];
            sb[start] ^= sb[end];
            start++;end--;
        }
    }
}
```

### 右旋字符串

将字符串的前k位移动到字符串的末尾

思路：先整体反转，再反转前k位和后n-k位

```java
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner in =new Scanner(System.in);
        int k = in.nextInt();
        String s = in.next();
        k = k%s.length();
        char[] sc = s.toCharArray();
        reverse(sc, 0, sc.length-1);
        reverse(sc, 0,k-1);
        reverse(sc, k,sc.length-1);
        System.out.println(new String(sc));
    }
    
    public static void reverse(char[] sc, int left, int right){
        char temp;
        while(left<right){
            temp = sc[left];
            sc[left] = sc[right];
            sc[right] = temp;
            left++;right--;
        }
    }
}
```

### StrStr(KMP算法)

寻找字符串B在字符串A中第一次出现的下标，若没有则返回-1

思路：构建next数组存储模式串(B)的公共前后缀的长度

```java
class Solution {
    public int strStr(String haystack, String needle) {
        // 创建next数组
        int[] next = buildNext(needle);
        int i=0,j=0;
        while(i<haystack.length()){
            // 相同则向后遍历
            if(haystack.charAt(i) == needle.charAt(j)){
                i++;j++;
            // 不同并且j>0则根据next数组回退
            }else if(j>0){
                j = next[j-1];
            // j为0的话,没有相同前缀,当前也不相同,i后移
            }else{
                i++;
            }
            // j遍历完则说明找到了匹配的串
            if(j>=needle.length()) return i-j;
        }
        return -1;
    }

    public int[] buildNext(String s){
        // 构建next数组,next数组值的含义为: 以当前下标(含)为结尾的子串的公共前后缀的长度
        int[] next = new int[s.length()];
        // same记录公共前后缀的长度
        for(int i=1, same=0;i<s.length();i++){
            // 当前遍历到的字符和前缀的最后一位的下一位相同,共同前后缀长度加一并写入next数组
            if(s.charAt(same) == s.charAt(i)){
                next[i] = ++same;
            }else{
                // 如果公共前缀长度为0则直接写入
                if(same==0){
                    next[i] = 0;
                // 
                }else{
                    i--;
                    same = next[same-1];
                }
            }  
        }
        return next;
    }
}
```

### 重复的子字符串

判断字符串s是否由重复的子字符串构成

思路: 将两个s拼接形成s+s，在新字符串中去除首尾字符，寻找是否存在s，若存在则说明s是由重复的子字符串构成的

```java
class Solution {

    public boolean repeatedSubstringPattern(String s) {
        String ss = s+s;
        // 创建next数组
        int[] next = buildNext(s);
        int i=1,j=0;
        while(i<ss.length()-1){
            // 相同则向后遍历
            if(ss.charAt(i) == s.charAt(j)){
                i++;j++;
            // 不同并且j>0则根据next数组回退
            }else if(j>0){
                j = next[j-1];
            // j为0的话,没有相同前缀,当前也不相同,i后移
            }else{
                i++;
            }
            // j遍历完则说明找到了匹配的串
            if(j>=s.length()) return true;
        }
        return false;
    }

    public int[] buildNext(String s){
        // 构建next数组,next数组值的含义为: 以当前下标(含)为结尾的子串的公共前后缀的长度
        int[] next = new int[s.length()];
        // same记录公共前后缀的长度
        for(int i=1, same=0;i<s.length();i++){
            // 当前遍历到的字符和前缀的最后一位的下一位相同,共同前后缀长度加一并写入next数组
            if(s.charAt(same) == s.charAt(i)){
                next[i] = ++same;
            }else{
                // 如果公共前缀长度为0则直接写入
                if(same==0){
                    next[i] = 0;
                // 
                }else{
                    i--;
                    same = next[same-1];
                }
            }  
        }
        return next;
    }
}
```

## 栈、队列

### 用栈实现队列

思路: 两个栈，一个负责输入，一个负责输出

```java
class MyQueue {
    Stack<Integer> stackIn = new Stack<>();
    Stack<Integer> stackOut = new Stack<>();
    // 用栈实现队列
    public MyQueue() {}
    
    // 入队列直接入输入栈
    public void push(int x) {
        stackIn.push(x);
    }

    // 出队列之前如果输出栈没有元素,则将输入栈的元素移入
    public void move(){
        if(stackOut.empty()){
            while(!stackIn.empty()) stackOut.push(stackIn.pop());
        }
        
    }
    // 输出
    public int pop() {
        move();
        return stackOut.pop();
    }
    // 查看顶部
    public int peek(){
        move();
        return stackOut.peek();
    }
    
    public boolean empty() {
        return stackIn.empty() && stackOut.empty();
    }
}

```

### 用队列实现栈

方法一：两个队列，每次取出元素时将前面的元素移动到备份队列中，然后再取出最后一个元素

```java
class MyStack {
    Queue<Integer> queue1 = new LinkedList<>();
    Queue<Integer> queue2 = new LinkedList<>();
    boolean use1 = true;

    public MyStack() {}
    
    public void push(int x) {
        if(use1){
            queue1.offer(x);
        }else{
            queue2.offer(x);
        }
    }
    
    public void change(){
        if(use1){
            while(queue1.size()!=1) queue2.offer(queue1.poll());
        }else{
            while(queue2.size()!=1) queue1.offer(queue2.poll());
        }
        use1 = !use1;
    }

    public int pop() {
        change();
        if(use1){
            return queue2.poll();
        }else{
            return queue1.poll();
        }
    }
    
    public int top() {
        change();
        int result;
        if(use1){
            result = queue2.poll();
            queue1.offer(result);
        }else{
            result = queue1.poll();
            queue2.offer(result);
        }
        return result;
        
    }
    
    public boolean empty() {
        return queue1.isEmpty() && queue2.isEmpty();
    }
}
```

方法二：一个队列，每次取出元素时将队列的前n-1个元素移动到队尾，最后一个元素则是要出栈的元素

```java
class MyStack {
    Queue<Integer> queue = new LinkedList<>();
    boolean use1 = true;

    public MyStack() {}
    
    public void push(int x) {
        queue.offer(x);
    }
    
    public void change(){
        int n = queue.size();
        while(n>1){
            queue.offer(queue.poll());
            n--;
        }
    }

    public int pop() {
        change();
        return queue.poll();
    }
    
    public int top() {
        change();
        int result = queue.poll();
        queue.offer(result);
        return result;
    }
    
    public boolean empty() {
        return queue.isEmpty();
    }
}
```

### 有效的括号

判断字符串内给出的括号是否可以成对闭合

思路: 左括号进栈，右括号与栈顶元素相比较，相同出栈，不同返回false

```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for(int i=0;i<s.length();i++){
            char c = s.charAt(i);
            if(c=='[' || c=='(' || c=='{'){
                stack.push(c);
            // 当前为有括号并且栈空返回假,当前为右括号且和栈顶不成对返回假
            }else if(stack.empty() || !check(stack.pop(),c)){
                return false;
            }
        }
        return stack.empty();
    }

    public boolean check(char a,char b){
        return (a=='[' && b==']') || (a=='{' && b=='}') || (a=='(' && b==')');
    }
}
```

### [删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

方法一：每一个元素入栈，利用栈来删除重复的字符

```java
public String removeDuplicates(String s) {
    Stack<Character> stack = new Stack<>();
    // 遍历每一个字符
    for(int i=0;i<s.length();i++){
        char c = s.charAt(i);
        // 栈为空或者当前字符和栈顶不一致则入栈
        if(stack.empty() || c!=stack.peek()){
            stack.push(c);
            // 否则栈顶出栈
        }else{
            stack.pop();
        }
    }
    // 拼接结果
    StringBuilder sb = new StringBuilder();
    for(char c: stack) sb.append(c);
    return sb.toString();
}
```

方法二：双指针法

```java
public String removeDuplicates(String s) {
    // 转化成字符数组
    char[] sc = s.toCharArray();
    int left=0,right=0;
    // 快指针每次遍历一个字符
    for(right=0;right<sc.length;right++){
        // 有指针的字符赋值给左指针
        sc[left] = sc[right];
        // 若左指针的值和上一个重复了,则左指针左移
        if(left!=0 && sc[left] == sc[left-1]){
            left--;
            // 否则左指针右移
        }else{
            left++;
        }
    }
    // 用数组转化成字符串对象
    return new String(sc,0,left);
}
```

### 逆波兰表达式求值

给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437) 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意：**

- 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 **向零截断** 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 **32 位** 整数表示。

 

**示例 1：**

```
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

思路: 使用栈临时存放数据，if-else比switch快

```java
class Solution {
    public int evalRPN(String[] tokens) {
        // Stack<Integer> stack = new Stack<>();
        // for(String s:tokens){
        //     if(s.equals("+") || s.equals("-") || s.equals("*") || s.equals("/")){
        //         switch(s){
        //             case "+": stack.push(stack.pop()+stack.pop()); break;
        //             case "-": stack.push(-stack.pop()+stack.pop()); break;
        //             case "*": stack.push(stack.pop()*stack.pop()); break;
        //             case "/": {
        //                 int b = stack.pop();
        //                 int a = stack.pop();
        //                 stack.push(a/b);
        //             }
        //         }
        //     }else{
        //         stack.push(Integer.parseInt(s));
        //     }
        // }
        // return stack.pop();
        Deque<Integer> stack = new LinkedList();
        for (String s : tokens) {
            if ("+".equals(s)) {        // leetcode 内置jdk的问题，不能使用==判断字符串是否相等
                stack.push(stack.pop() + stack.pop());      // 注意 - 和/ 需要特殊处理
            } else if ("-".equals(s)) {
                stack.push(-stack.pop() + stack.pop());
            } else if ("*".equals(s)) {
                stack.push(stack.pop() * stack.pop());
            } else if ("/".equals(s)) {
                int temp1 = stack.pop();
                int temp2 = stack.pop();
                stack.push(temp2 / temp1);
            } else {
                stack.push(Integer.valueOf(s));
            }
        }
        return stack.pop();
    }
}
```

### 滑动窗口的最大值

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

思路: 单调队列，随着窗口的移动向队列中加入和取出元素，需要用到java中的Deque，Deque的方法如下所示

单调队列共包含三个方法:

- push() 若要入队的元素大于队尾元素，则移除队尾元素，直到队列空或者队尾元素大于等于要入队的元素，则新元素入队
- pop() 若要出队的元素和队头元素一致，则允许出队，否则不操作
- getFirst() 获取当前队列中最大的值(队头)

![image-20240313100153743](%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95.assets/image-20240313100153743.png)

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] result = new int[nums.length-k+1];
        int index = 0;
        // k个长度的窗口,一方入队,一方出队,始终返回队头值()最大值
        MoQueue moQueue = new MoQueue( );
        int left=0, right=k;
        // 初始窗口内元素先入队
        for(int i=0;i<right;i++) moQueue.push(nums[i]);
        while(right<nums.length){
            result[index++] = moQueue.getFirst();
            // 入队
            moQueue.push(nums[right]);
            // 出队
            moQueue.pop(nums[left]);
            left++;right++;
        }
        result[index] = moQueue.getFirst( );
        return result;
    }
}

class MoQueue{
    // 用双端队列实现单调队列
    // pop(),poll(),都是删除队头元素,getFirst为读取队头元素,getLast为读取队尾元素
    Deque<Integer> queue = new ArrayDeque<>();
    public MoQueue(){}
    // 入队的元素比当前队列的最小值(入口)大,则移除最小值,直到当前元素小于等于最小值
    public void push(int x){
        while (!queue.isEmpty() && queue.getLast()<x) queue.pollLast();
        queue.offerLast(x);
    }

    // 出队的元素等于出口元素,则允许出队,否则无操作
    public void pop(int x){
        if(getFirst()==x) queue.pollFirst();
    }

    public Integer getFirst(){
        // 返回队头元素
        return queue.getFirst();
    }
}
```

### 前k个高频元素

返回数组中出现次数最高的k个元素

思路：使用优先级队列，将计数的数量作为优先级，然后去除前k个

比较器，2-1是大的在前，1-2是小的在前

```java
public int[] topKFrequent(int[] nums, int k) {
    int[] result = new int[k];
    // 优先级队列,取元素时默认取出最小的
    PriorityQueue<int[]> pq = new PriorityQueue<int[]>((o1, o2) -> o2[1]-o1[1]);
    HashMap<Integer, Integer> counts = new HashMap<>(  );
    // 计数
    for (int num : nums) counts.put(num, counts.getOrDefault(num,0)+1);
    for (Map.Entry<Integer, Integer> entry : counts.entrySet( )) {
        pq.add(new int[]{entry.getKey(),entry.getValue()});
    }
    for (int i = 0; i < k; i++) {
        result[i] = pq.poll()[0];
    }
    // 统计元素出现次数,出现次数和元素值入堆
    return result;
}
```

### 最小栈

设计一个能在常数时间内获取到最小值的栈，思路：使用辅助栈来记录最小值

```java
class MinStack {
    //  借助一个辅助栈实现
    Stack<Integer> nums;
    Stack<Integer> mins;
    Integer min = null;
    public MinStack() {
        nums = new Stack<>();
        mins = new Stack<>();
    }
    
    public void push(int val) {
        nums.push(val);
        // 当前值比最小值小,或栈里不存在最小值,当前值就是最小值
        if(min==null || val<min) min = val;
        mins.push(min);
    }
    
    public void pop() {
        nums.pop();
        mins.pop();
        // 出栈之后根据栈顶更新最小值
        if(mins.isEmpty()){
            min = null;
        }else{
            min = mins.peek();
        }
    }
    
    public int top() {
        return nums.peek();
    }
    
    public int getMin() {
        return min;
    }
}
```



## 二叉树

### 二叉树的三序遍历

思路: 左子树-右子树-节点值，前中后序改变的就是三个语句的顺序

```java
List<Integer> result = new ArrayList();
public List<Integer> postorderTraversal(TreeNode root) {
    if(root==null) return result;
    postorderTraversal(root.left);
    postorderTraversal(root.right);
    result.add(root.val);
    return result;
}
```

### 迭代遍历二叉树

前序遍历: 用栈实现，根节点入栈，每次循环取出栈顶元素并输出，然后出栈元素的右节点和左节点先后入栈

```java
class Solution {
    List<Integer> result = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        // 迭代法实现前序遍历
        // 借助栈来实现
        if(root==null) return result;
        stack.push(root);
        while(!stack.empty()){
            TreeNode node = stack.pop();
            if(node.right!=null) stack.push(node.right);
            if(node.left!=null) stack.push(node.left);
            result.add(node.val);
        }
        return result;
        // 1,2,4,5,3,6,7
    }
}
```

中序遍历：用栈实现，根节点入栈，然后左节点继续入栈，直到左节点为空，然后栈顶元素出栈，出栈后的元素的右节点和他的递归左节点入栈

```java
class Solution {
    List<Integer> result = new ArrayList();
    Stack<TreeNode> stack = new Stack<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        // 迭代法实现中序遍历(左、中、右)
        if(root==null) return result;
        do{
            // 有左节点则左节点入栈
            while(root!=null){
                stack.push(root);
                root = root.left;
            }
            // 栈顶元素输出到结果
            root = stack.pop();
            result.add(root.val);
            // 栈顶元素的右节点入栈，右节点的所有左节点入栈
            root = root.right;
        }while(!stack.empty() || root!=null);
        return result;
    }
}
```

后序遍历：

解法一：按照先序的思路改变左右

```java
class Solution {
    List<Integer> result = new ArrayList();
    Stack<TreeNode> stack = new Stack<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        // 按照先序遍历的思路，替换左右节点入栈的顺序，输出时反向输出结果即可
        if(root == null) return result;
        stack.push(root);
        while(!stack.empty()){
            root = stack.pop();
            if(root.left !=null) stack.push(root.left);
            if(root.right !=null) stack.push(root.right);
            result.add(root.val);
        }
        Collections.reverse(result);
        return result;
    }
}
```

解法二：借助空值标记节点状态

```java
class Solution {
    List<Integer> result = new ArrayList();
    Stack<TreeNode> stack = new Stack<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        if(root == null) return result;
        // 根节点入栈
        stack.push(root);
        while(!stack.empty()){
            // 出栈一个元素
            root = stack.pop();
            // 若出栈元素不为空,则代表当前元素左右节点未入栈
            if(root!=null){
                // 后输出的先入栈,且带上一个空值
                stack.push(root);
                stack.push(null);
                // 左右孩子入栈
                if(root.right!=null) stack.push(root.right);
                if(root.left!=null) stack.push(root.left);
            }else{
                // 若取出的值为空代表下一个值可以输出
                result.add(stack.pop().val);
            }
        }
        return result;
    }
}
```

### 统一迭代法

二叉树的统一迭代方法就是将要返回的节点用空值做标记

前序: 

```java
class Solution {
    List<Integer> result = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        // 迭代法实现前序遍历 中-左-右
        if(root==null) return result;
        // 根节点入栈
        stack.push(root);
        while(!stack.empty()){
            root = stack.pop();
            if(root!=null){
                if(root.right!=null) stack.push(root.right);
                if(root.left!=null) stack.push(root.left);
                stack.push(root);stack.push(null);
            }else{
                result.add(stack.pop().val);
            }
        }
        return result;
    }
}
```

中序:

```java
class Solution {
    List<Integer> result = new ArrayList();
    Stack<TreeNode> stack = new Stack<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        // 迭代法实现中序遍历 左-中-右
        if(root==null) return result;
        // 根节点入栈
        stack.push(root);
        while(!stack.empty()){
            root = stack.pop();
            if(root!=null){
                if(root.right!=null) stack.push(root.right);
                stack.push(root);stack.push(null);
                if(root.left!=null) stack.push(root.left);
            }else{
                result.add(stack.pop().val);
            }
        }
        return result;
    }
}
```

后序:

```java
class Solution {
    List<Integer> result = new ArrayList();
    Stack<TreeNode> stack = new Stack<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        if(root == null) return result;
        // 根节点入栈
        stack.push(root);
        while(!stack.empty()){
            // 出栈一个元素
            root = stack.pop();
            // 若出栈元素不为空,则代表当前元素左右节点未入栈
            if(root!=null){
                // 后输出的先入栈,且带上一个空值
                stack.push(root);stack.push(null);
                // 左右孩子入栈
                if(root.right!=null) stack.push(root.right);
                if(root.left!=null) stack.push(root.left);
            }else{
                // 若取出的值为空代表下一个值可以输出
                result.add(stack.pop().val);
            }
        }
        return result;
    }
}
```

### 二叉树的层序遍历

思路：借助队列实现，每次统计队列大小，出队一层的元素

```java
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> resut = new LinkedList<>();
        // 队列,add入队,poll出队
        Queue<TreeNode> queue = new LinkedList<>();
        if(root==null) return resut;
        queue.add(root);
        while(queue.size()!=0){
            int n = queue.size();
            List<Integer> line = new ArrayList<>();
            for(int i=0;i<n;i++){
                TreeNode node = queue.poll();
                line.add(node.val);
                if(node.left!=null) queue.add(node.left);
                if(node.right!=null) queue.add(node.right);
            }
            resut.add(0, line);
        }
        return resut;
    }
}
```

### 二叉树的右视图

从右向左看，能看到二叉树的哪些节点，按从上至下的顺序返回

```java
class Solution {
    Queue<TreeNode> queue = new LinkedList<>();
    List<Integer> result = new ArrayList();
    public List<Integer> rightSideView(TreeNode root) {
        if(root==null) return result;
        queue.offer(root);
        while(queue.size()!=0){
            // 按行遍历
            for(int n=queue.size();n>0;n--){
                // 出队
                root = queue.poll();
                if(root.left!=null) queue.offer(root.left);
                if(root.right!=null) queue.offer(root.right);
                // 如果是一行的最后一个节点,则返回
                if(n==1) result.add(root.val);
            }
        }
        return result;
    }
}
```

### 返回二叉树一行的平均值

```java
class Solution {
    Queue<TreeNode> queue = new LinkedList<>();
    List<Double> result = new ArrayList();
    public List<Double> averageOfLevels(TreeNode root) {
        if(root==null) return result;
        queue.offer(root);
        while(queue.size()!=0){
            long sum = 0;
            int size=queue.size();
            // 按行遍历
            for(int n=size;n>0;n--){
                // 出队
                root = queue.poll();
                if(root.left!=null) queue.offer(root.left);
                if(root.right!=null) queue.offer(root.right);
                // 如果是一行的最后一个节点,则返回
                sum+=root.val;
            }
            result.add((double)sum/size);
        }
        return result;
    }
}
```

### N叉树的层序遍历

```java
class Solution {
    public List<List<Integer>> levelOrder(Node root) {
                List<List<Integer>> resut = new ArrayList<>();
        // 队列,add入队,poll出队
        Queue<Node> queue = new LinkedList<>();
        if(root==null) return resut;
        queue.add(root);
        while(queue.size()!=0){
            int n = queue.size();
            List<Integer> line = new ArrayList<>();
            for(int i=0;i<n;i++){
                Node node = queue.poll();
                line.add(node.val);
                for(Node cnode:node.children){
                   queue.add(cnode);
                }
            }
            resut.add(line);
        }
        return resut;
    }
}
```

### 在每个树行中找最大值

```java
class Solution {
    List<Integer> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList();
    public List<Integer> largestValues(TreeNode root) {
        if(root==null) return result;
        queue.offer(root);
        while(queue.size()!=0){
            int max = Integer.MIN_VALUE;
            for(int n=queue.size();n>0;n--){
                root = queue.poll();
                if(root.left!=null) queue.offer(root.left);
                if(root.right!=null) queue.offer(root.right);
                max = Math.max(max,root.val);
            }
            result.add(max);
        }
        return result;
    }
}
```

### 填充每个节点的下一个右侧指针

```java
class Solution {
    Queue<Node> queue = new LinkedList<>();
    public Node connect(Node root) {
        // 使用层序遍历
        if(root==null) return root;
        queue.offer(root);
        while(queue.size()!=0){
            Node pre = null,now = null;
            for(int n=queue.size();n>0;n--){
                pre = now;
                now = queue.poll();
                if(now.left!=null) queue.offer(now.left);
                if(now.right!=null) queue.offer(now.right);
                if(pre!=null) pre.next = now;
            }
        }
        return root;
    }
}
```

### 二叉树的最大深度

解法一: 递归解法

```java
class Solution {
    public int maxDepth(TreeNode root) {
        // 递归写法,左子树的最大深度和右子树的最大深度取最大值,然后加一返回
        return root!=null?Math.max(maxDepth(root.left),maxDepth(root.right))+1:0;
    }
}
```

解法二: 层序遍历

```java
class Solution {
    Queue<TreeNode> queue = new LinkedList<>();
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        int max = 0;
        queue.offer(root);
        while(queue.size()!=0){
            max++;
            for(int n=queue.size();n>0;n--){
                root = queue.poll();
                if(root.left!=null) queue.offer(root.left);
                if(root.right!=null) queue.offer(root.right);
            }
        }
        return max;
    }
}
```

### 二叉树的最小深度

解法一: 递归解法

```java
class Solution {
    public int minDepth(TreeNode root) {
        // 递归写法,左子树的最小深度和右子树的最小深度取最小值,然后加一返回
        if(root==null) return 0;
        // 是叶子节点,返回1
        if(root.left==null && root.right==null) return 1;
        // 只有一个孩子返回这一个孩子的值+1
        if(root.left==null) return minDepth(root.right)+1;
        if(root.right==null) return minDepth(root.left)+1;
        // 两个孩子都有返回两个孩子的最小值+1
        return Math.min(minDepth(root.left),minDepth(root.right))+1;
    }
}
```

解法二: 层序遍历

```java
class Solution {
    Queue<TreeNode> queue = new LinkedList<>();
    public int minDepth(TreeNode root) {
        if(root==null) return 0;
        int min = Integer.MAX_VALUE;
        int floor = 0;
        queue.offer(root);
        while(queue.size()!=0){
            floor++;
            for(int n=queue.size();n>0;n--){
                root = queue.poll();
                if(root.left==null && root.right==null) min = Math.min(floor,min);
                if(root.left!=null) queue.offer(root.left);
                if(root.right!=null) queue.offer(root.right);
            }
        }
        return min;
    }
}
```

### 翻转二叉树

使用递归法，交换左右节点即可

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root!=null){
            TreeNode temp = root.left;
            root.left = root.right;
            root.right = temp;
            invertTree(root.left);
            invertTree(root.right);
        }

        return root;
    }
}
```

也可使用统一的迭代法

```java
class Solution {
    Stack<TreeNode> stack = new Stack<>();
    public TreeNode invertTree(TreeNode root) {
        // 迭代法实现前序遍历 中-左-右
        if(root==null) return root;
        // 根节点入栈
        stack.push(root);
        while(!stack.empty()){
            TreeNode temp = stack.pop();
            if(temp!=null){
                if(temp.right!=null) stack.push(temp.right);
                if(temp.left!=null) stack.push(temp.left);
                stack.push(temp);stack.push(null);
            }else{
                temp = stack.pop();
                TreeNode swap = temp.left;
                temp.left = temp.right;
                temp.right = swap;
            }
        }
        return root;
    }
}
```

### 对称二叉树

判断一个二叉树是否轴对称

使用迭代法一次入两个元素

```java
class Solution {
    // Stack<TreeNode> stack = new Stack<>();
    public boolean isSymmetric(TreeNode root) {
        return isSame(root.left,root.right);
        // // 使用迭代模式判断树是否对称
        // stack.push(root.left);stack.push(root.right);
        // while(!stack.isEmpty()){
        //     TreeNode left = stack.pop(),right = stack.pop();
        //     if(left==right) continue;
        //     if(left==null || right==null || left.val!=right.val) return false;
        //     stack.push(left.left);stack.push(right.right);
        //     stack.push(left.right);stack.push(right.left);
        // }
        // return true;
    }

    public boolean isSame(TreeNode p, TreeNode q){
        // 左右子树对称并且根节点相同
        if(p==null && q==null){return true;}
        if(p==null || q==null){return false;}
        return p.val==q.val && isSame(p.left,q.right) && isSame(p.right,q.left);
    }
}
```

### 相同的树

判断两个二叉树是否完全相同

```java
class Solution {
    Stack<TreeNode> stack = new Stack<>();
    public boolean isSameTree(TreeNode p, TreeNode q) {
        // 迭代法: 一次入两个值
        stack.push(p);stack.push(q);
        while(!stack.isEmpty()){
            p = stack.pop();q=stack.pop();
            if(p==null && q==null) continue;
            if(p==null || q==null || p.val!=q.val) return false;
            stack.push(p.left);stack.push(q.left);
            stack.push(p.right);stack.push(q.right);
        }
        return true;
        // 递归法: 左右子树相同并且根节点相同
        // if(p==null && q==null){return true;}
        // if(p==null || q==null){return false;}
        // return p.val==q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);
    }
}
```

### 另一棵树的子树

还有另一种思路是将树序列化然后用KMP算法判断子串

```java
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        // 三种情况:
        // 1.当前节点为根和subRoot结构相同
        // 2.当前的左节点为根和subRoot结构相同
        // 3.当前的右节点为根和subRoot结构相同
        if(root==null && subRoot==null) return true;
        if(root==null) return false;
        return isSame(root,subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);
    }
    // p,q是否完全相同
    public boolean isSame(TreeNode p, TreeNode q){
        // 左右子树相同并且根节点相同
        if(p==null && q==null){return true;}
        if(p==null || q==null){return false;}
        return p.val==q.val && isSame(p.left,q.left) && isSame(p.right,q.right);
    }
}
```

```python
class Solution:
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        lst1 = []
        lst2 = []
        def make(r, lst):
            if r:
                lst.append(f"<{r.val}>")
                make(r.left, lst)
                make(r.right, lst)
            else:
                lst.append(".")
        make(root, lst1)
        make(subRoot, lst2)
        r1 = ",".join(lst1)
        r2 = ",".join(lst2)
        print(r2, "\n",r1)
        return r2 in r1
```

### n叉树的最大深度

迭代法思路与二叉树一致

```java
class Solution {
    Queue<Node> queue = new LinkedList<>();
    public int maxDepth(Node root) {
        // 层序遍历找最大深度
        int floor = 0;
        if(root==null) return floor;
        queue.offer(root);
        while(!queue.isEmpty()){
            floor ++;
            for(int n=queue.size();n>0;n--){
                root = queue.poll();
                for(Node node:root.children){
                    queue.offer(node);
                }
            }
        }
        return floor;
    }
}
```

递归法:

```java
class Solution {
    public int maxDepth(Node root) {
        if(root==null) return 0;
        // 若没有子节点则说明当前是叶子节点,返回1
        if(root.children.isEmpty()) return 1;
        // 存储最大值
        int max = Integer.MIN_VALUE;
        for(Node node: root.children){
            max = Math.max(maxDepth(node), max);
        }
        // 返回子节点的最大值+1
        return max+1;
    }
}
```

### 完全二叉树的节点个数

递归法: 

```java
class Solution {
    public int countNodes(TreeNode root) {
        if(root==null) return 0;
        // 左子树的节点数+右子树的节点数+根(1)等于总的个数
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
}
```

公式法:

完全二叉树不一定是满二叉树，但他的一部分肯定是满二叉树

满二叉树：所有层都达到了最大节点数，满二叉树的节点个数是：(2^n)-1，n为树的深度

完全二叉树：要么是满二叉树，要么最后一层不满，最后一层不满时，最后一层的所有节点全部排列在左侧

```java
class Solution {
    public int countNodes(TreeNode root) {
        // 向左遍历的层数等于向右遍历的层数时,这个树就是个满二叉树,当一个树是满二叉树时,节点的个数等于2^n-1,n为树的深度
        if(root==null) return 0;
        TreeNode left = root.left;
        TreeNode right = root.right;
        int lc=0, rc=0;
        // 左右找最深,并记录深度
        while(left!=null){left = left.left; lc++;}
        while(right!=null){right = right.right; rc++;}
        if(lc==rc){
            // 左移n位是 2^(n+1)
            return (2<<lc)-1;
        }
        // 常规递归法
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
}
```

### 平衡二叉树

判断一个树是否为高度平衡二叉树(任意一个节点的左右子树高度差不大于1)

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        if(root==null) return true;
        int dl = deep(root.left);
        int dr = deep(root.right);
        // 高度差超过1
        if((dl-dr>0?dl-dr:dr-dl)>1){
            return false;
        }else{
            return isBalanced(root.left) && isBalanced(root.right);
        }
    }

    // 左右子树深度差不超过1
    public int deep(TreeNode root){
        if(root==null) return 0;
        return Math.max(deep(root.left), deep(root.right))+1;
    }
}
```

### 二叉树所有的路径

```java
class Solution {
    List<String> result = new ArrayList<>();
    public List<String> binaryTreePaths(TreeNode root) {
        // 一个数组记录路径
        calc(root,new ArrayList<Integer>());
        return result;
    }
    // 递归+回溯法,列表记录路径,遇到叶子节点就添加结果,出递归删除末尾节点
    public void calc(TreeNode node, List<Integer> temp){
        // 当前节点加入列表
        temp.add(node.val);
        // 叶子节点
        if(node.left == null && node.right == null){
            // 拼接结果并返回
            StringBuilder sb = new StringBuilder();
            for(int i=0;i<temp.size();i++){
                sb.append(temp.get(i));
                if(i!=temp.size()-1) sb.append("->");
            }
            result.add(sb.toString());
            return;
        }
        // 左不为空向左遍历
        if(node.left!=null){
            calc(node.left,temp);
            // 出递归要删除末尾节点
            temp.remove(temp.size()-1);
        }
        if(node.right!=null){
            calc(node.right,temp);
            temp.remove(temp.size()-1);
        }
    }
}
```

### 左叶子节点之和

给定二叉树的根节点 `root` ，返回所有左叶子之和。

递归法: 

```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        return sum(root, false);
    }
    // 标志是否是左节点
    public int sum(TreeNode root, boolean left){
        // 是空返回0
        if(root==null) return 0;
        // 是左节点并且是叶子节点
        if(left && root.left==null && root.right==null) return root.val;
        // 递归返回
        return sum(root.left, true) + sum(root.right, false);
    }
}
```

迭代法:

```java
class Solution {
    Stack<TreeNode> stack = new Stack<>();
    public int sumOfLeftLeaves(TreeNode root) {
        int result = 0;
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode node = stack.pop();
            if(node.left!=null && node.left.left==null && node.left.right==null) result+=node.left.val;
            if(node.left!=null) stack.push(node.left);
            if(node.right!=null) stack.push(node.right);
        }
        return result;
    }
}
```

### 找树左下角的值

迭代法: 使用层序遍历

```java
class Solution {
    Queue<TreeNode> queue = new LinkedList<>();
    public int findBottomLeftValue(TreeNode root) {
        // 层序遍历,记录每层的第一个值,遍历完了则是结果
        queue.offer(root);
        int result=0;
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int n=size;n>0;n--){
                TreeNode node = queue.poll();
                if(n==size) result = node.val;
                if(node.left!=null) queue.offer(node.left);
                if(node.right!=null) queue.offer(node.right);
            }
        }
        return result;
    }
}
```

递归法:

用变量记录最大深度和第一次到达最大深度时的值

```java
class Solution {
    // 最大深度
    int maxDeep = Integer.MIN_VALUE;
    int result = 0;
    public int findBottomLeftValue(TreeNode root) {
        find(root, 0);
        return result;
    }

    public void find(TreeNode node, int deep){
        // 当前层数大于记录的最大深度时更新值
        if(deep>maxDeep && node.left==null && node.right==null){
            maxDeep = deep;
            result = node.val;
        }
        // 继续递归
        if(node.left!=null) find(node.left, deep+1);
        if(node.right!=null) find(node.right, deep+1);
    }
}
```

### 路径总和

返回二叉树中是否存在从根节点到叶子节点,路径和等于sum的路径,若有返回true

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        // 根节点为空返回否
        if(root==null) return false;
        // 是叶子节点返回当前的值是否等于sum
        if(root!=null && root.left==null && root.right==null) return targetSum==root.val;
        // 否则递归遍历
        return hasPathSum(root.left, targetSum-root.val) || hasPathSum(root.right, targetSum-root.val);
    }
}
```

### 路径总和2

返回二叉树中从根节点到叶子节点,路径和等于sum的所有路径

递归的同时，使用回溯法，注意添加到结果时不可直接添加temp，要对他进行复制

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    List<Integer> temp = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        calc(root, targetSum);
        return result;
    }

    public void calc(TreeNode root, int targetSum){
        // 根节点为空返回否
        if(root==null) return;
        temp.add(root.val);
        // 是叶子节点返回当前的值是否等于sum
        if(root!=null && root.left==null && root.right==null && targetSum==root.val){
            // 返回当前结果
            List<Integer> copy = new ArrayList<>();
            for(int i=0;i<temp.size();i++){
                copy.add(temp.get(i));
            }
            result.add(copy);
        }
        // 否则递归遍历
        if(root.left!=null){
            calc(root.left, targetSum-root.val);
            temp.remove(temp.size()-1);
        }
        if(root.right!=null){
            calc(root.right, targetSum-root.val);
            temp.remove(temp.size()-1);
        }
        return;
    }
}
```

### 从中序与后序遍历构造二叉树

思路: 先通过后序确定根节点，再在中序序列中找到根节点，以根节点为分界线将数组分割，然后根据分割出来的长度分割后序数组

这个过程用递归实现，可以不传递实际的数据，用下标表示

```java
class Solution {
    int[] inorder;
    int[] postorder;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        this.inorder = inorder;
        this.postorder = postorder;
        return build(0,inorder.length,0,postorder.length);
    }
    // 用四个指针来表示数组,前闭,后开
    public TreeNode build(int inLeft, int inRight, int postLeft, int postRight){
        // 1.若后序数组为空则返回空
        if(postLeft>=postRight || inLeft>=inRight) return null;
        // 2.若后序数组有值,则根据后序数组的最后一位,构建根节点
        TreeNode root = new TreeNode(postorder[postRight-1]);
        int cut;
        for(cut=inLeft;cut<inRight;cut++){
            // 找到切割点
            if(inorder[cut] == root.val){
                break;
            }
        }
        // 3.根据根节点切割中序数组
        // 4.根据中序数组的切割结果切割后序数组
        // 5.递归切割开的两个数组
        // cut-前序的开头为偏移的距离
        cut = cut-inLeft;
        root.left = build(inLeft, inLeft+cut, postLeft, postLeft+cut);
        root.right = build(inLeft+cut+1, inRight, postLeft+cut, postRight-1);
        return root;
    }
}
```

### 从先序与中序遍历构造二叉树

思路与后序与中序构造相似

```java
class Solution {
    int[] preorder;
    int[] inorder;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.preorder = preorder;
        this.inorder = inorder;
        return build(0, preorder.length, 0, inorder.length);
    }
    // 根据下标递归遍历
    public TreeNode build(int left1, int right1, int left2, int right2){
        if(left1>=right1 || left2>=right2) return null;
        // 先序遍历的第一个是头结点
        TreeNode root = new TreeNode(preorder[left1]);
        // 根据头节点找到中序遍历的中间切割点
        int cut;
        for(cut=left2;cut<right2;cut++){
            if(inorder[cut] == root.val) break;
        }
        cut = cut-left2;
        // 左半部分 先序: [left1+1, left1+cut+1] 中序: [left2, left2+cut]
        root.left = build(left1+1, left1+cut+1, left2, left2+cut);
        // 右半部分 先序: [left1+cut+1, right1] 中序: [left2+cut+1, right2]
        root.right = build(left1+cut+1, right1, left2+cut+1, right2);
        return root;
    }
}
```

### 最大二叉树

通过一个数组构建二叉树，数组中的最大值为根节点，最大值左边的是左子树，右边的是右子树

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return build(nums, 0, nums.length);
    }

    public TreeNode build(int[] nums, int start, int end){
        if(start>=end) return null;
        int max = Integer.MIN_VALUE;int maxi = 0;
        // 寻找最大节点
        for(int i=start;i<end;i++){
            if(nums[i]>max){
                max = nums[i]; maxi = i;
            }
        }
        // 最大节点为根
        TreeNode root = new TreeNode(max);
        // 以最大节点为分界线,进行递归
        root.left = build(nums, start, maxi);
        root.right = build(nums, maxi+1, end);
        return root;
    }
}
```

### 合并二叉树

使用递归法，可以新建节点，也可以直接用老的节点（更省空间）

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1==null && root2==null) return null;
        // 其中一个为空,则后面的树都是不为空的这个的子树
        if(root1==null) return root2;
        if(root2==null) return root1;
        // 都不为空的情况,根节点值相加
        TreeNode root = new TreeNode(root1.val+root2.val);
        // 左右子树递归合并
        root.left = mergeTrees(root1.left, root2.left);
        root.right = mergeTrees(root1.right, root2.right);
        return root;
    }
}
```

### 二叉搜索树中的搜索

递归法:

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        // 二叉搜索树,左小右大
        // 根节点为空或者值就是要找的值,则返回
        if(root==null || root.val==val) return root;
        // 要找到值小于根节点,去左子树找
        if(val<root.val) return searchBST(root.left, val);
        // 要找的值大于根节点去右子树找
        if(val>root.val) return searchBST(root.right, val);
        return null;
    }
}
```

迭代法:

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        while(root!=null){
            if(root.val==val) return root;
            else if(val<root.val) root = root.left;
            else if(val>root.val) root = root.right;
        }
        return null;
    }
}
```

### 验证二叉搜索树是否合法

思路: 递归验证,左子树的最大值是原来的根节点,右子树的最小值是原来的根节点

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        // 根节点无论如何都合法,左右子树合法即可
        return  judge(root.left, Integer.MIN_VALUE-1L, root.val) && 
                judge(root.right, root.val, Integer.MAX_VALUE+1L);
    }

    public boolean judge(TreeNode root, long min, long max){
        // 当前节点合法,当前左子树合法,当前右子树合法
        if(root==null) return true;
        // 当前节点值合法, 左右子树合法
        return  root.val<max && 
                root.val>min && 
                judge(root.left, min, root.val) && 
                judge(root.right, root.val, max);
    }
}
```

### 二叉搜索树的最小绝对差

给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

差值是一个正数，其数值等于两值之差的绝对值。

思路: 二叉搜索树有序，中序遍历结果为一个有序数组，所以按照中序遍历的顺序，用指针记录上一次遍历的值，即可得出结果

```java
class Solution {
    TreeNode pre = null;
    TreeNode now = null;
    int min = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
        if(root==null) return 0;
        // 二叉搜索树的中序遍历是一个有序数组(左-中-右)
        // 那么在中序遍历的过程中记录值就好了
        // 左
        getMinimumDifference(root.left);
        // 中,两个记录指针移动,最小值更新
        pre = now;now = root;
        if(pre!=null && now!=null) min = Math.min(min, Math.abs(now.val-pre.val));
        // 右
        getMinimumDifference(root.right); 
        return min;
    }
}
```

### 二叉搜索树中的众数

```java
class Solution {
    List<Integer> result = new ArrayList();
    int count=Integer.MIN_VALUE;
    int maxCount=Integer.MIN_VALUE;
    // 上一次遍历的节点
    TreeNode pre;
    
    public int[] findMode(TreeNode root) {
        inOrder(root);
        int[] arr = new int[result.size()];
        for(int i=0;i<result.size();i++){
            arr[i] = result.get(i);
        }
        return arr;
    }

    // 中序遍历
    public void inOrder(TreeNode root){
        if(root==null) return;
        inOrder(root.left);
        // 开启新的一轮计数
        if(pre==null || pre.val!=root.val){
            count = 1;
        // 否则计数+1
        }else if(pre.val == root.val){
            count++;
        }
        // 当前大于最大的计数,清空众数列表
        if(count>maxCount){
            maxCount = count;
            result.clear();
        }
        // 当前计数等于最大的计数,放入众数列表
        if(count==maxCount){
            result.add(root.val);
        }
        
        pre = root;
        inOrder(root.right);
    }
}
```

### 二叉树的最近公共祖先

思路: 后序遍历,先从左右两子树中找，找到节点返回节点值

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 使用后序遍历，在某个树中寻找
        // 左,右,中
        // 找到节点返回
        if(root==null || root==p || root==q) return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        // left,right为空代表从这两边都没有找到p,q
        if(left==null && right==null) return null;
        // 其中一个不为空代表还没找到,返回不为空的这一边
        if(left!=null && right==null) return left; 
        if(left==null && right!=null) return right;
        // 都不为空代表找到了公共祖先
        return root; 
    }
}
```

### 二叉搜索树的最近公共祖先

因为二叉搜索树有序的特性，在寻找时可比对大小，然后只找一个方向

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 如果当前值在p和q的左边，向右遍历
        if(root.val<p.val && root.val<q.val) return lowestCommonAncestor(root.right, p, q);
        // 如果当前值在p和q的右边，向左遍历
        if(root.val>p.val && root.val>q.val) return lowestCommonAncestor(root.left, p, q);
        // 如果都不是,说明已经在区间内,在区间内的直接返回
        return root;
    }
}
```

### 二叉搜索树的插入操作

递归解法按方向递归即可

```java
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        // 递归到当前的值为空,则说明找到了插入点,可以创建节点并返回
        if(root==null) return new TreeNode(val);
        // 根据值的大小寻找插入的方向
        if(root.val<val){
            // 如果有返回的节点的话,进行赋值
            root.right = insertIntoBST(root.right, val);
        }else if(root.val>val){
            root.left = insertIntoBST(root.left, val);
        }
        // 返回根节点
        return root;
    }
}
```

### 二叉搜索树的删除操作

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root==null) return root;
        // 递归寻找要删除的节点
        if(root.val<key){
            root.right = deleteNode(root.right, key);
            return root;
        }
        if(root.val>key){
            root.left = deleteNode(root.left, key);
            return root;
        }
        // 找到了
        // 1.当前节点无左右孩子
        if(root.left==null && root.right==null) return null;
        // 2.当前节点只有左孩子
        if(root.left!=null && root.right==null) return root.left;
        // 3.当前节点只有右孩子
        if(root.right!=null && root.left==null) return root.right;
        // 4.左右孩子都有,将左孩子节点插入到右孩子的最左上
        insert(root.left, root.right);
        return root.right;
    }

    public void insert(TreeNode left, TreeNode right){
        while(right.left!=null) right = right.left;
        right.left = left;
    }
}
```

### 修剪二叉搜索树

给定一个数字范围，去掉超出这个范围的节点，返回修剪完的树

```java
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if(root==null) return root;
        // 遍历+删除左右子树
        root.left = trimBST(root.left, low, high);
        root.right = trimBST(root.right, low, high);
        // 根节点若在范围外也删除
        if(root.val<low || root.val>high){
            root = deleteNode(root);
        }
        // 返回新的根节点
        return root;
    }

    public TreeNode deleteNode(TreeNode root) {
        if(root==null) return root;
        // 1.当前节点无左右孩子
        if(root.left==null && root.right==null) return null;
        // 2.当前节点只有左孩子
        if(root.left!=null && root.right==null) return root.left;
        // 3.当前节点只有右孩子
        if(root.right!=null && root.left==null) return root.right;
        // 4.左右孩子都有,将左孩子节点插入到右孩子的最左上
        insert(root.left, root.right);
        return root.right;
    }

    public void insert(TreeNode left, TreeNode right){
        while(right.left!=null) right = right.left;
        right.left = left;
    }
}
```

### 有序数组转为二叉搜索树

思路: 使用二分法递归，中间点是根节点

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return build(nums, 0, nums.length);
    }
    // 用下标定位数组左右边界
    public TreeNode build(int[] nums, int i, int j){
        // 下标重合了代表没元素了
        if(i>=j) return null;
        // 找到中点作为根
        int mid = (i+j)/2;
        // 构建根 
        TreeNode root = new TreeNode(nums[mid]);
        // 递归左右(二分法)
        root.left = build(nums, i, mid);
        root.right = build(nums, mid+1, j);
        return root;
    }
}
```

### 二叉搜索树转换为累加树

给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

思路: 反向的中序遍历即可

```java
class Solution {
    int sum = 0;
    // 求累加和,二叉搜索树的中序遍历是有序的: 左-中-右是升序,右-中-左是降序
    public TreeNode convertBST(TreeNode root) {
        if(root==null) return null;
        // 右
        convertBST(root.right);
        // 中
        sum+=root.val;root.val = sum;
        // 左
        convertBST(root.left);
        return root;
    }
}
```

### 二叉树展开为链表

思路: 左右先展开,按照先序遍历的顺序,中-左-右拼接起来即可

```java
class Solution {
    // 根节点不变,左子树先展开,右子树再展开,都放在根的右孩子上
    public void flatten(TreeNode root) {
        change(root);
    }

    public TreeNode change(TreeNode root){
        if(root==null) return null;
        // 左右分别展开
        TreeNode left = change(root.left);
        TreeNode right = change(root.right);
        // 根节点的右指针应该是什么
        TreeNode next;
        // 左为空,根节点的右指针右
        if(left==null){
            next = right;
        // 左不为空,根节点的右指针就是原来的左
        }else{
            // 把原来的右拼接到原来的左的末尾
            while(left.right!=null) left = left.right;
            left.right = right;
            next = root.left;
            // 根节点左置空
            root.left = null;
        }
        // 拼接根节点的右
        root.right = next;
        // 返回根节点
        return root;
    }
}
```

## 回溯法

### 理论基础

回溯法本质是在穷举

回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

![image-20240322101809241](%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95.assets/image-20240322101809241.png)

### 组合问题

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

普通回溯法: 一层for循环遍历一个元素，然后递归处理后面的元素中选择k-1个数的情况，用临时列表进行记录和回溯操作

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    List<Integer> temp = new ArrayList<>();

    public List<List<Integer>> combine(int n, int k) {
        select(1, n, k);
        return result;
    }
    // 在[left,right]区间中找k个值
    public void select(int left, int right, int k){
        // 遍历到最后,临时集合拷贝加入结果
        if(k==0){
            List<Integer> line = new ArrayList<>();
            for(int i: temp){
                line.add(i);
            }
            result.add(line);
        }
        // 遍历
        for(int i=left;i<=right;i++){
            // 当前元素入临时集合
            temp.add(i);
            select(i+1, right, k-1);
            // 回溯,当前元素出
            temp.remove(temp.size()-1);
        }
    }
}
```

剪枝操作: 减少循环次数

```java
// 遍历 (当元素个数不足以构成k个的集合时,不需要进入循环)
for(int i=left;i<=right && right-i+1>=k;i++){
    // 当前元素入临时集合
    temp.add(i);
    select(i+1, right, k-1);
    // 回溯,当前元素出
    temp.remove(temp.size()-1);
}
```

### 组合总和III

在1-9中挑选k个数，和为n

```java
class Solution {
    List<List<Integer>> result = new ArrayList();
    List<Integer> temp = new ArrayList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        // 1-9中挑选k个数,之和为n
        select(1,k,n);
        return result;
    }

    public void select(int i, int k, int n){
        if(n==0 && k==0){
            result.add(new ArrayList(temp));
        }
        if(k==0) return;
        for(int j=i;j<=9;j++){
            temp.add(j);
            // 和减去当前数,k-1
            select(j+1,k-1,n-j);
            temp.remove(temp.size()-1);
        }
    }
}
```

### 电话号码的字母组合

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

```java
class Solution {
    // 数字与字母的映射关系
    String[] map = new String[]{
        "","","abc","def",
        "ghi","jkl","mno",
        "pqrs","tuv","wxyz"
    };
    // 临时数组存储当前的组合
    char[] temp = new char[256];
    // 对临时数组进行操作的指针
    int index=0;
    List<String> result = new ArrayList<>();
    
    public List<String> letterCombinations(String digits) {
        if(digits.length()==0) return result;
        build(digits.toCharArray(),0,digits.length());
        return result;
    }
    // ['2','3']
    public void build(char[] digits, int start, int n){
        // 遍历到最后一个字符.临时变量表示的组合加到结果中
        if(start==n){
            result.add(new String(temp,0,index));
            return;
        }
        // 取出当前数字对应的字符组合
        String s = map[digits[start]-'0'];
        // 遍历字符组合
        for(int i=0;i<s.length();i++){
            // 递归
            temp[index++] = s.charAt(i);
            build(digits, start+1, n);
            // 回溯
            temp[index--] = 0;
        }
    }
}
```

### 组合总和

元素不重复的数组中，找出和为target的组合，单个元素可以重复使用

思路：递归时不用i+1，代表当前元素可重复使用

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    int sum=0;
    List<Integer> temp = new ArrayList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        select(candidates,0,target);
        return result;
    }

    public void select(int[] nums, int start,int target){
        // 等于结果了,进行添加
        if(sum==target){
            result.add(new ArrayList(temp));
            return;
        }
        for(int i=start;i<nums.length;i++){
            // 当前数超了跳过当前数,走下一个数
            if(sum+nums[i]>target) continue;
            // 递归
            temp.add(nums[i]);sum+=nums[i];
            // 不需要i+1,代表当前元素可多次选择
            select(nums, i, target);sum-=nums[i];
            // 回溯
            temp.remove(temp.size()-1);
        }
    }
}
```

### 组合总和II

有重复元素的数组中，找出和为target的组合，组合内可以有重复元素，结果集中不能有重复组合

思路：使用used数组记录一个元素是否被使用，为真代表上一层使用过（组合内）,为假代表这一层使用过(组合间),used数组伴随着其他值同时递归和回溯

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    List<Integer> temp = new ArrayList<>();
    boolean[] used;

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        used = new boolean[candidates.length];
        // 需要先排序
        Arrays.sort(candidates);
        select(candidates, 0, 0, target);
        return result;
    }

    public void select(int[] nums, int start, int sum, int target){
        if(sum==target){
            result.add(new ArrayList<>(temp));
        }
        for(int i=start;i<nums.length;i++){
            if(sum+nums[i]>target) break;
            // used[i-1]为true代表上一层使用过,为false代表这一层使用过
            if(i!=0 && nums[i]==nums[i-1] && !used[i-1]) continue;
            // 递归和回溯
            temp.add(nums[i]);used[i] = true;
            select(nums, i+1, sum+nums[i], target);
            temp.remove(temp.size()-1); used[i] = false;
        }
    }
}
```

### 分割回文串

将一个大字符串分割成多个小字符串，这些小字符串都是回文串，返回所有的分割结果

思路: 

1. 回文串的判断使用动态规划，二维数组dp\[i\]\[j\]代表从\[i,j\]是否是回文串
2. 将回文串的长度入临时集合，找到结果时依次遍历即可取出结果

```java
class Solution {
    char[] sc;
    boolean[][] dp;
    int n;

    public void makeDp(String s){
        // 首先想办法动态规划一个串是不是回文串
        dp = new boolean[n][n];
        // i代表回文串的起始下标,j代表回文串的结束下标,从后向前遍历
        for(int i=s.length();i>=0;i--){
            for(int j=i;j<s.length();j++){
                // 就一个字符,必定为回文
                if(i==j){
                    dp[i][j] = true;
                // 两个字符,他们两个相等就是回文
                }else if(i==j-1){
                    dp[i][j] = sc[i] == sc[j];
                // 多个字符,首尾相等且中间相等就是回文
                }else{
                    dp[i][j] = sc[i] == sc[j] && dp[i+1][j-1];
                }
            }
        }
        // System.out.println(Arrays.deepToString(dp));
    }
    // 结果集合
    List<List<String>> result = new ArrayList<>();
    // 临时数组,存储切割点
    List<Integer> temp = new ArrayList<>();

    public List<List<String>> partition(String s) {
        sc = s.toCharArray();
        n = s.length();
        makeDp(s);
        cut(0);
        return result;
    }

    public void cut(int start){
        // 找到结果了
        if(start>=n){
            List<String> line = new ArrayList<>();
            int index = 0;
            // 切割操作
            for(int i:temp){
                line.add(new String(sc,index,i));
                index = index+i;
            }
            // 放入结果
            result.add(line);
            return;
        }
        for(int i=start;i<n;i++){
            // 从起点到当前不是回文,跳过这层循环
            if(!dp[start][i]) continue;
            // 递归和回溯
            temp.add(i-start+1);
            cut(i+1);
            temp.remove(temp.size()-1);
        }
    }
}
```

不使用动态规划和记录切割长度，直接使用双指针判断，使用subString函数切割

```java
class Solution {
    char[] sc;
    int n;
    String s;
    
    // 结果集合
    List<List<String>> result = new ArrayList<>();
    // 临时数组,存储切割结果
    Deque<String> temp = new LinkedList<>();

    public List<List<String>> partition(String s) {
        this.s = s;
        sc = s.toCharArray();
        n = s.length();
        cut(0);
        return result;
    }

    public void cut(int start){
        // 找到结果了
        if(start>=n){
            // 放入结果
            result.add(new ArrayList(temp));
            return;
        }
        for(int i=start;i<n;i++){
            // 从起点到当前不是回文,跳过这层循环
            if(isHw(start,i)){
                // 递归和回溯
                temp.addLast(s.substring(start,i+1));
                cut(i+1);
                temp.removeLast();
            }else{
                continue;
            }
        }
    }

    public boolean isHw(int i,int j){
        while(i<j){
            if(sc[i]!=sc[j]) return false;
            i++;j--;
        }
        return true;
    }
}
```

### 复原IP地址

思路: 使用subString截取ip的一部分,使用join函数拼接点号和IP的四个部分，ip一段最大三位，最多四段，超过这些情况的直接返回

```java
class Solution {
    List<String> result = new ArrayList<>();
    String[] temp = new String[4];
    int index = 0;
    public List<String> restoreIpAddresses(String s) {
        select(s,0,s.length());
        return result;
    }

    public void select(String s, int start, int n){
        if(start>=n && index==4){
            // 添加结果
            // System.out.println(String.join(".",temp));
            result.add(String.join(".",temp));
            return;
        }
        if(index==4) return;
        for(int i=start;i<Math.min(n,start+3);i++){
            String sub = s.substring(start,i+1);
            if(isIp(sub)){
                temp[index++] = sub;
                select(s,i+1,n);
                temp[--index] = null;
            }else{
                continue;
            }
        }
    }

    // 判断一个ip是否合法
    public boolean isIp(String ip){
        // 长度不合适直接返回0
        if(ip.length()<=0 || ip.length()>3) return false;
        // 长度不为1且首位是0不合法
        if(ip.length()>1 && ip.charAt(0)=='0') return false;
        // 长度为1始终合法
        if(ip.length()==1) return true;
        return Integer.parseInt(ip)<=255;
    }
}
```

### 子集

求一个集合的所有子集(包括空)

思路: 正常递归回溯，过程中出现的每一个都返回就是最终结果

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    Deque<Integer> temp = new LinkedList<>();

    public List<List<Integer>> subsets(int[] nums) {
        select(nums, 0, nums.length);
        // 添加最后的空数组
        result.add(new ArrayList<>());
        return result;
    }

    public void select(int[] nums, int start, int n){
        for(int i=start;i<n;i++){
            temp.add(nums[i]);
            // 遍历过程中的每一个临时变量都入结果,
            result.add(new ArrayList<>(temp));
            select(nums,i+1,n);
            temp.removeLast();
        }
    }
}
```

### 子集II

和上一题不同的是，这一题的集合有重复元素

思路：先对nums排序，循环的时候去重即可，引入used数组，used[i]为真代表上一层用过,否则代表这一层用过

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    Deque<Integer> temp = new LinkedList<>();
    boolean[] used;

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        used = new boolean[nums.length];
        Arrays.sort(nums);
        select(nums, 0, nums.length);
        // 添加最后的空数组
        result.add(new ArrayList<>());
        return result;
    }

    public void select(int[] nums, int start, int n){
        for(int i=start;i<n;i++){
            if(i!=0 && nums[i]==nums[i-1] && !used[i-1]) continue;
            temp.add(nums[i]);used[i] = true;
            // 遍历过程中的每一个临时变量都入结果,
            result.add(new ArrayList<>(temp));
            select(nums,i+1,n);
            temp.removeLast(); used[i] = false;
        }
    }
}
```

### 非递减子序列

思路：最重要的就是去重，使用used数组记录是否重复，只需要记录一个父节点下是否重复即可

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    Deque<Integer> temp = new LinkedList<>();

    public List<List<Integer>> findSubsequences(int[] nums) {
        select(nums, 0, nums.length);
        return result;
    }

    public void select(int[] nums, int start, int n){
        // 记录一个父节点下某个元素是否重复使用
        boolean[] used = new boolean[201];
        for(int i=start;i<n;i++){
            // 未被重复使用 并且能过构成递增序列
            if(!used[nums[i]+100] && (temp.isEmpty() || temp.getLast()<=nums[i])){
                // 递归回溯
                temp.add(nums[i]);used[nums[i]+100] = true;
                // 长度为1的不返回
                if(temp.size()!=1) result.add(new ArrayList(temp));
                select(nums, i+1, n);
                temp.removeLast();
            }
        }
    }
}
```

### 全排列

求一个不含重复元素的集合的全排列

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    Deque<Integer> temp = new LinkedList<>();
    boolean[] used;

    public List<List<Integer>> permute(int[] nums) {
        used = new boolean[nums.length];
        select(nums, nums.length);
        return result;
    }

    public void select(int[] nums, int n){
        // 临时列表满了说明找到了一种排列
        if(temp.size()==n){
            result.add(new ArrayList<>(temp));
            return;
        }
        // 每次从头遍历,因为不是按顺序选择的,需要used数组才知道哪个没被用过
        for(int i=0;i<n;i++){
            // 使用过的元素跳过
            if(used[i]) continue;
            // 其他元素递归回溯
            temp.add(nums[i]);used[i] = true;
            select(nums, n);
            temp.removeLast();used[i] = false;
        }
    }
}
```

### 全排列II

不同于上一题，这一题会出现重复元素，先排序再补充去重逻辑即可

```java
// 值相同的时候,used为false代表当前和上一个元素在同一层说明用过
if(i!=0 && nums[i]==nums[i-1] && !used[i-1]) continue;
// 当前元素在其它层用过
if(used[i]) continue;
```



## 蓝桥杯模拟赛

### 9.Y字形

问题描述

　　对于一个字符矩阵，其中的一些字符构成字母 Y 是指存在一个中间字符，从这个中间字符向下、向左上（45度）、向右上（45度）的字符都与中间的字符相同。
　　字母 Y 的长度指同时向 3 个方向的相同字母延伸的最大距离。
　　例如，下图中所有的 1 组成一个字母 Y，长度为 3。
　　又如，下图中以第 5 行第 6 列为中心也构成一个字母 Y （由字符 A 构成），长度为 1 。
　　再如，下图中以第 4 行第 3 列为中心也构成一个字母 Y （由字符 0 构成），长度为 2 。
　　1000001
　　0100010
　　0010100
　　0001AAA
　　00010A0
　　00010A0
　　00010A0
　　给定一个字符矩阵，请找出能构成字母 Y 的最大长度，如果无法构成字母 Y，请输出 0 。

输入格式

　　输入的第一行包含两个整数 n, m ，用一个空格分隔，表示字符矩阵的行数和列数。
　　接下来 n 行，每行包含 m 个字符，表示字符矩阵。

输出格式

　　输出一行包含一个整数，表示答案。

样例输入

7 7
1000001
0100010
0010100
0001AAA
00010A0
00010A0
00010A0

样例输出

3

评测用例规模与约定

　　对于50%的评测用例，1 <= n, m <= 100。
　　对于所有评测用例，1 <= n, m <= 1000，字符矩阵中仅包含数字字符和大写英文字母。

```java

//机器人判分系统要求必须如下规则：
// 1： 不能有package关键字
// 2： 类名必须是Main

import java.util.Scanner;
public class Main {
    static Scanner in = new Scanner(System.in);
    static int i,j;
    public static void main(String[] args) {

        i = in.nextInt();
        j = in.nextInt();
        int[][] arr = new int[i][j];
        // 遍历输入
        for (int arr_i = 0; arr_i < i; arr_i++) {
            String s = in.next();
            for (int arr_j = 0; arr_j < j; arr_j++) {
                arr[arr_i][arr_j] = s.charAt(arr_j);
            }
        }
        int max = 0;
        for (int arr_i = 1; arr_i < i-1; arr_i++) {
            for (int arr_j = 1; arr_j < j-1; arr_j++) {
                max = Math.max(Y(arr, arr_i, arr_j),max);
            }
        }
        System.out.println(max );
    }
    public static int Y(int[][] arr, int arr_i, int arr_j) {
        // 判断以一个坐标为中心能否生成Y字形,最大生成多大
        // 左上角的指针,右上角的指针,正下方的指针
        // 左上角的指针,右上角的指针,正下方的指针
        int[] p1 = new int[]{arr_i-1,arr_j-1};
        int[] p2 = new int[]{arr_i-1,arr_j+1};
        int[] p3 = new int[]{arr_i+1,arr_j};
        int count=0;
        while(true){
            // 三个指针越界
            if(p1[0]<0 || p1[1]<0) return count;
            if(p2[0]<0 || p2[1]>=j) return count;
            if(p3[0]>=i) return count;
            if (arr[p1[0]][p1[1]] == arr[arr_i][arr_j] && arr[p2[0]][p2[1]] == arr[arr_i][arr_j] && arr[p3[0]][p3[1]] == arr[arr_i][arr_j]) {
                count++;
                p1[0]--;p1[1]--;
                p2[0]--;p2[1]++;
                p3[0]++;
            }else{
                return count;
            }
        }

    }
}

```



### 10.上楼梯

问题描述

　　小蓝要上一个楼梯，楼梯共有 n 级台阶（即小蓝总共要走 n 级）。小蓝每一步可以走 a 级、b 级或 c 级台阶。
　　请问小蓝总共有多少种方案能正好走到楼梯顶端？

输入格式

　　输入的第一行包含一个整数 n 。
　　第二行包含三个整数 a, b, c 。

输出格式

　　输出一行包含一个整数，表示答案。答案可能很大，请输出答案除以 1000000007 后的余数。

样例输入

4
1 2 3

样例输出

7

样例输入

7
2 4 6

样例输出

0

评测用例规模与约定

　　对于 30% 评测用例，1 <= a < b < c <= n <= 50。
　　对于 60% 评测用例，1 <= a < b < c <= n <= 1000。
　　对于所有评测用例，1 <= a < b < c <= n <= 1000000。

```java

//机器人判分系统要求必须如下规则：
// 1： 不能有package关键字
// 2： 类名必须是Main

import java.util.Scanner;
public class Main {
    static Scanner in = new Scanner(System.in);
    static int a,b,c;
    public static void main(String[] args) {
        int n = in.nextInt();
        a = in.nextInt();
        b = in.nextInt();
        c = in.nextInt();
        // a<b<c<=n
        System.out.println(calc2(n) % 1000000007);
    }

    public static int calc(int n){
        if(n==a || n==0){
             return 1;
        }
        if(n<a){
            return 0;
        }
        return calc(n-a)+calc(n-b)+calc(n-c);
    }

    public static long calc2(int n){
        // 动态规划写法
        long[] dp = new long[n];
        dp[a-1] = 1;
        dp[b-1] = 1;
        dp[c-1] = 1;
        for(int i=a;i<n;i++){
            dp[i]+=dp[i-a];
            if(i>=b){
                dp[i]+=dp[i-b];
            }
            if(i>=c){
                dp[i]+=dp[i-c];
            }
            dp[i] = dp[i]%1000000007;
        }
        return dp[n-1];
    }
}
	
```


# 	2023/10/3

## 回文数 leetcode.9

https://leetcode.cn/problems/palindrome-number/description/

思路: 一位数一位数的倒转,直到倒转的部分比前半部分大,进行比较

```java
class Solution {
    public boolean isPalindrome(int x) {
        if(x<0 || (x%10 == 0 && x!=0)) return false;
        int r = 0;
        while(r<x){
            r = r*10+x%10;
            x = x/10;
        }
        return x==r || x==r/10;
    }
}
```

## 合并数组 leetcode.88

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

思路: 正向不好操作,可以反向遍历,判断哪一位能被放进最后一位

```java
// 自己的写法
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        m--;n--;
        int k = m+n+1;
        while(n>=0){
            int b = nums2[n];
            if(m<0){
                nums1[k] = b;
                n--;
            }else{
                int a = nums1[m];
                if(a > b){
                    nums1[k] = a;
                    m--;
                }else{
                    nums1[k] = b;
                    n--;
                }
            }
            k--;
        }
    }
}

// 题解的写法
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        m--;n--;
        int k = m+n+1;
        while(n>=0){
            // 使用while可以减少判断次数,因为数组是有序的
            while(m>=0 && nums1[m]>nums2[n]){
                nums1[k--] = nums1[m--];continue;
            }
            nums1[k--] = nums2[n--];
        }
    }
}
```

# 2023/10/4

## 原地删除元素 leetcode.27

给定一个数组和待删除的值,要求使用O(1) 的额外空间删除元素

思路: 双指针，一前一后进行遍历，右指针可以用for遍历，左右指针的命名可以用left，right而不是i，j可读性高

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        // // 两个指针遍历数组
        // int i=0,j=0;
        // int n = nums.length;
        // while(i<n){
        //     if(nums[i]!=val){
        //         nums[j++] = nums[i++];
        //     }else{
        //         i++;
        //     }
        // }
        // return j;
        int left = 0;
        for(int right=0;right<nums.length;right++){
            if(nums[right] != val){
                nums[left++] = nums[right];
            }
        }
        return left;
    }
}
```

## 删除重复元素 leetcode.26

非递减数组中删除重复元素，使用原地算法，这里重复的必定相邻，返回删除后数组的长度

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int left=0,flag=nums[0];
        // 双指针遍历数组
        for(int right=0;right<nums.length;right++){
            int n = nums[right];
            if(n != flag){
                // 原思路: 不相等时就将右赋值给左
                // nums[++left] = n;
                // flag = n;
                // 优化: 两个数据相邻时就不复制
                if(right-left>1){
                    nums[++left] = n;
                }else{
                    left++;
                }
                flag = n;
            }
        }
        return left+1;
    }
}
```

# 2023/10/5

## 删除重复元素2 leetcode.80

给你一个有序数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使得出现次数超过两次的元素**只出现两次** ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

思路: 使用双指针，

题解: 

```java
public int removeDuplicates(int[] nums) {
    int n = nums.length;
    if(n<2) return n;
    // 删除重复元素,让一个元素最多出现两次
    int left=2;
    for(int right=2;right<n;right++){
        // 当左指针的前面两位和右指针指向的不相同时就可以赋值
        if(nums[left-2] != nums[right]){
            nums[left++] = nums[right];
        }
    }
    return left;
}
```

## 多数元素 leetcode.169

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

解法一:

遍历数组并将所有的结果存储到hash表中

```java
public int majorityElement(int[] nums) {
    int n = nums.length;
    int m = n/2;

    HashMap<Integer, Integer> map = new HashMap<>();

    for(int num:nums){
        map.put(num,map.getOrDefault(num,0)+1);
    }
    Stream<Map.Entry<Integer, Integer>> sorted = map.entrySet( ).stream( ).sorted(
        (entry1,entry2)-> -entry1.getValue().compareTo(entry2.getValue())
    );

    return sorted.collect(Collectors.toList()).get(0).getKey();
}
```

解法二:

```java
public int majorityElement(int[] nums) {
    int count=0,log=nums[0];
    // log为候选众数,当前遍历的数与他相等时,count+1,不等时count-1,count=0时换数
    for(int num:nums){
        if(count==0){
            log = num;
        }
        if(num==log){
            count++;
        }else{
            count--;
        }
    }
    return log;
}
```

证明: 

思路

如果我们把众数记为 +1+1+1，把其他数记为 −1-1−1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。

算法

Boyer-Moore 算法的本质和方法四中的分治十分类似。我们首先给出 Boyer-Moore 算法的详细步骤：

我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；

我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：

如果 x 与 candidate 相等，那么计数器 count 的值增加 1；

如果 x 与 candidate 不等，那么计数器 count 的值减少 1。

在遍历完成后，candidate 即为整个数组的众数。

我们举一个具体的例子，例如下面的这个数组：

[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
在遍历到数组中的第一个元素以及每个在 | 之后的元素时，candidate 都会因为 count 的值变为 0 而发生改变。最后一次 candidate 的值从 5 变为 7，也就是这个数组中的众数。

Boyer-Moore 算法的正确性较难证明，这里给出一种较为详细的用例子辅助证明的思路，供读者参考：

首先我们根据算法步骤中对 count 的定义，可以发现：在对整个数组进行遍历的过程中，count 的值一定非负。这是因为如果 count 的值为 0，那么在这一轮遍历的开始时刻，我们会将 x 的值赋予 candidate 并在接下来的一步中将 count 的值增加 1。因此 count 的值在遍历的过程中一直保持非负。

那么 count 本身除了计数器之外，还有什么更深层次的意义呢？我们还是以数组

[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
作为例子，首先写下它在每一步遍历时 candidate 和 count 的值：

nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
candidate:  7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7
count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4
我们再定义一个变量 value，它和真正的众数 maj 绑定。在每一步遍历时，如果当前的数 x 和 maj 相等，那么 value 的值加 1，否则减 1。value 的实际意义即为：到当前的这一步遍历为止，众数出现的次数比非众数多出了多少次。我们将 value 的值也写在下方：

nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4
有没有发现什么？我们将 count 和 value 放在一起：

nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4
value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4
发现在每一步遍历中，count 和 value 要么相等，要么互为相反数！并且在候选众数 candidate 就是 maj 时，它们相等，candidate 是其它的数时，它们互为相反数！

为什么会有这么奇妙的性质呢？这并不难证明：我们将候选众数 candidate 保持不变的连续的遍历称为「一段」。在同一段中，count 的值是根据 candidate == x 的判断进行加减的。那么如果 candidate 恰好为 maj，那么在这一段中，count 和 value 的变化是同步的；如果 candidate 不为 maj，那么在这一段中 count 和 value 的变化是相反的。因此就有了这样一个奇妙的性质。

这样以来，由于：

我们证明了 count 的值一直为非负，在最后一步遍历结束后也是如此；

由于 value 的值与真正的众数 maj 绑定，并且它表示「众数出现的次数比非众数多出了多少次」，那么在最后一步遍历结束后，value 的值为正数；

在最后一步遍历结束后，count 非负，value 为正数，所以它们不可能互为相反数，只可能相等，即 count == value。因此在最后「一段」中，count 的 value 的变化是同步的，也就是说，candidate 中存储的候选众数就是真正的众数 maj。

Java
Python3
C++
class Solution {
    public int majorityElement(int[] nums) {
        int count = 0;
        Integer candidate = null;

        for (int num : nums) {
            if (count == 0) {
                candidate = num;
            }
            count += (num == candidate) ? 1 : -1;
        }
    
        return candidate;
    }

链接：https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/

# 2023/10/6

## 轮转数组 leetcode.189

数组内所有元素循环向右移动k位

```java
public void rotate(int[] nums, int k) {
    // 1.使用额外的数组存储
    // int n = nums.length;
    // k = k%n;
    // if(k==0) return;
    // int[] newNums = new int[n];
    // int i=0;
    // do{
    //     newNums[k] = nums[i];
    //     k = (k+1)%n;
    //     i++;
    // }while(i!=n);
    // System.arraycopy(newNums,0,nums,0,n);
    
    // 2.循环轮转, 第0位的元素移动到0+k处,0+k处的元素移动到0+2k处
    // int n = nums.length;
    // k = k%n;
    // if(k==0) return;
    // int count=0,start=0;
    // while(count!=n){
    //     int i=start;
    //     int temp = nums[i];
    //     do{
    //         count++;
    //         i = (i+k)%n;
    //         temp = nums[i]+temp;
    //         nums[i] = temp-nums[i];
    //         temp = temp-nums[i];
    //     }while(i!=start);
    //     start++;
    // }

    // 3.数组翻转, 先整体翻转,再分别翻转前后半部分
    int n = nums.length;
    k = k%n;
    reverse(nums, 0, n-1);
    reverse(nums, 0, k-1);
    reverse(nums, k, n-1);
}
public void reverse(int nums[], int start, int end){
    while(start<end){
        int temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
        start++;end--;
    }
}
```

## 买卖股票的最佳时机 leetcode.121

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

```java
public int maxProfit(int[] prices) {
    // 记录最小值
    int min=prices[0];
    // 记录最大利润
    int lr = 0;
    for(int num: prices){
        // 始终记录历史最低点
        min = Math.min(min,num);
        // 当前的最小值和当前天的相差的利润谁最大
        lr = Math.max(lr,num-min);
    }
    return lr;
}
```

# 2023/10/7

## 买卖股票的最佳时机 leetcode.122

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

思路: 动态规划，二维数组dp[i][j]表示第i天持股状态为j时的最大现金数，当后续状态只和前一个状态有关时，可以使用滚动变量来节省空间

```java
public int maxProfit(int[] prices) {
    int n = prices.length;
    if(n<2){
        return 0;
    }
    // // 二维数组dp[i][j]表示第i天持股状态为j时的最大现金数
    // int[][] dp = new int[n][2];
    // // 第一天若不持有股票则有0元
    // dp[0][0] = 0;
    // // 若持有股票则有-prices[0]元
    // dp[0][1] = -prices[0];
    // for(int i=1;i<n;i++){
    //     // 这一天的钱为,原先持有股票卖出,或者原先不持有股票
    //     dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i]);
    //     // 这一天持股为,原先就持有,或者原先没有,今天买入
    //     dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-prices[i]);
    // }
    // return dp[n-1][0];
    // 用滚动变量节省空间
    int cash=0,hold=-prices[0];
    int preCash,preHold;
    for(int i=1;i<n;i++){
        preCash = cash;preHold = hold;
        cash = Math.max(preCash, preHold+prices[i]);
        hold = Math.max(preHold, preCash-prices[i]);
    }
    return cash;
}
```

## 跳跃游戏 leetcode.55

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

本质也是动态规划的思想

dp[i]代表走到i位时最大可以调到的位置

dp[i] = max(dp[i-1], i+nums[i]);

进行空间优化,dp[]变成一个变量max

```java
public boolean canJump(int[] nums) {
    int n = nums.length;
    if(n<2) return true;
    // 初始最远可以跳到哪里
    int max = nums[0];
    for(int i=0;i<max+1;i++){
        // 当前位置加上当前格子的最远可以跳到的位置,和原本最远可以跳到的位置取最大
        max = Math.max(i+nums[i],max);
        if(max>=n-1) return true;
    }
    return false;
}
```

# 2023/10/8

## 跳跃游戏2 leetcode.45

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

思路: 使用变量记录步数和当前步能到达的最远处,过了这个最远处就是下一步的了

 ```java
public int jump(int[] nums) {
    int n = nums.length;
    if(n<2) return 0;
    int jump = 0;
    // 最远可以跳到哪里
    int max = 0;
    // 这一步最远可以跳到哪里
    int stepMax = nums[0];
    for(int i=0;i<n-1;i++){
        // 当前位置加上当前格子的最远可以跳到的位置,和原本最远可以跳到的位置取最大
        max = Math.max(i+nums[i],max);
        // 跳到了当前步的最远处,更新步数和当前步的最远处
        if(i==stepMax){
            stepMax = max;
            jump++;
        }
    }
    return jump;
}
 ```

## H指数 leetcode.274

给你一个整数数组 `citations` ，其中 `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数。计算并返回该研究者的 **`h` 指数**。

根据维基百科上 [h 指数的定义](https://baike.baidu.com/item/h-index/3991452?fr=aladdin)：`h` 代表“高引用次数” ，一名科研人员的 `h` **指数** 是指他（她）至少发表了 `h` 篇论文，并且每篇论文 **至少** 被引用 `h` 次。如果 `h` 有多种可能的值，**`h` 指数** 是其中最大的那个。

```java
public int hIndex(int[] citations) {
    // 思路1: 计数统计
    // 被引用大于h的都算在nums[h]内
    // 要找最大的nums[h] >= h

    // int n = citations.length;
    // int[] nums = new int[n+1];
    // for(int i=0;i<n;i++){
    //     for(int j=0;j<=Math.min(n,citations[i]);j++){ nums[j]++;}
    // }
    // for(int j=n;j>=0;j--){
    //     if(nums[j]>=j) return j;
    // }
    // return 0;
    
    // 思路2: 排序
    Arrays.sort(citations);
    int j = citations.length-1;
    int h=0;
    // 从大到小遍历,当前遍历的值(引用次数)比记录的h大,则h+1
    while(j>=0 && citations[j]>h){
        h++;
        j--;
    }
    return h;
}
```

# 2023/10/9

## O(1)时间插入删除获取随机元素 leetcode.380

o(1)时间复杂度需要用哈希表来实现

```java
class RandomizedSet {

    Set<Integer> set;
    Random r;

    public RandomizedSet() {
        set = new HashSet<>();
        r = new Random();
    }
    
    public boolean insert(int val) {
        if(!set.contains(val)){
            set.add(val);
            return true;
        }else{
            return false;
        }
    }
    
    public boolean remove(int val) {
        if(set.contains(val)){
            set.remove(val);
            return true;
        }else{
            return false;
        }
    }
    
    public int getRandom() {
        ArrayList<Integer> a = new ArrayList<Integer>(set);
        return a.get(r.nextInt(0,a.size()));
    }
}
```

## 除自身以外数组的乘积 leetcode.238

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] r = new int[n];
        // 1.借助两个数组存储左乘积和右乘积
        // int[] left = new int[n];
        // int[] right = new int[n];
        // left[0] = 1;
        // right[n-1] = 1;
        // int i=1,j=n-2;
        // while(i<n && j>=0){
        //     left[i] = left[i-1]*nums[i-1];
        //     right[j] = right[j+1]*nums[j+1];
        //     i++;j--;
        // }
        
        // for(i=0;i<n;i++){
        //     r[i] = left[i]*right[i];
        // }

        // 2.直接用返回数组存左前缀
        r[0] = 1;
        // 先把每个表的左面元素的乘积记录下来
        for(int i=1;i<n;i++){
            r[i] = r[i-1] * nums[i-1];
        }
        int right = 1;
        // 写入结果
        for(int j=n-1;j>=0;j--){
            r[j] = r[j] * right;
            right = right*nums[j];
        }
        return r;
    }
}
```

# 2023/10/10

## 加油站 leetcode.134

在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。

![image-20231010163842649](%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98.assets/image-20231010163842649.png)

思路: 用折线表示油箱内的油，以油最少的时刻作为起点

```java
public int canCompleteCircuit(int[] gas, int[] cost) {
    int sum = 0;
    int min = Integer.MAX_VALUE;
    int mini = 0;
    for(int i=0;i<gas.length;i++){
        sum = sum+(gas[i]-cost[i]);
       	// 现在计算的其实是i+1的折线点
        if(sum<min){
            mini = i;
            min = sum;
        }
    }
    // 折线的最底端大于等于0,则从0开始即可
    if(min>=0) return 0;
    return sum<0?-1:(mini+1)%gas.length;
}
```

## 分发糖果 leetcode.135

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

思路: 分两次遍历，先判断一个孩子和他左面的谁大，大的应该要比左面的拿到的多一个

第二次遍历，大的应该要比他右面的拿到的多一个，最终两个值取最大

```java
public int candy(int[] ratings) {
    int n = ratings.length;
    int[] left = new int[n];
    int right,sum;
    // 右不用数组,一个变量累计
    right = 1;
    left[0] = 1;
    for(int i=1;i<n;i++){
        left[i] = ratings[i]>ratings[i-1]?left[i-1]+1:1;
    }
    sum = Math.max(right,left[n-1]);
    for(int j=n-2;j>=0;j--){
        right = ratings[j]>ratings[j+1]?right+1:1;
        sum += Math.max(left[j],right);
    }
    return sum;
}
```

# 2023/10/11

## 接雨水 leetcode.42

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

 

**示例 1：**

![img](%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98.assets/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

思路一:

按行遍历，先遍历第一行，左右比大当前行高就可以存水，一直到最高一行

```java
int len=Arrays.stream(height).max().getAsInt(),h=0, sum=0;
int n = height.length;
while(h<len){
    Integer left=null;
    // 遍历一层
    for(int i=0;i<n;i++){
        if(height[i] > h){
            if(left!=null){
                sum += i-left-1;
            }
            left = i;
        }
    }
    h++;
}
return sum;
```

思路二:

按列遍历,找一列左边最高的墙和右边最高的墙,这两个里面小的一方跟当前列的高度比较

```java
int n = height.length;
int sum = 0;
for(int i=1;i<n-1;i++){
    int maxLeft = Integer.MIN_VALUE;
    int maxRight = Integer.MIN_VALUE;
    for(int k=0;k<i;k++){
        maxLeft = Math.max(maxLeft, height[k]);
    }
    for(int k=i+1;k<n;k++){
        maxRight = Math.max(maxRight, height[k]);
    }
    int min = Math.min(maxLeft,maxRight);
    if(min>height[i]){
        sum += min-height[i];
    }
}
return sum;
```

思路三:

动态规划,左边最高的和右边最高的记录为数组

```java
int n = height.length;
int sum = 0;
int left[] = new int[n];
int right[] = new int[n];
left[0] = 0;right[n-1] = 0;
for(int i=1;i<n;i++){
    left[i] = Math.max(height[i-1],left[i-1]);
}
for(int i=n-2;i>=0;i--){
    right[i] = Math.max(height[i+1],right[i+1]);
}
for(int i=1;i<n-1;i++){
    int min = Math.min(left[i], right[i]);
    if(min>height[i]){
        sum += min-height[i];
    }
}
return sum;
```

## 罗马数字转整数 leetcode.13

罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 1 。`12` 写做 `XII` ，即为 `X` + `II` 。 `27` 写做 `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。

```java
public int romanToInt(String s) {
    // 左<右则结果减左,否则加左
    // s.charAt();

    int sum=0;
    int pre = getVal(s.charAt(0));
    // 长度为1时直接返回now,也就是第一位
    int now=pre;
    for(int i=1;i<s.length();i++){
        now = getVal(s.charAt(i));
        // 当前位和前一位比较,前一位小的话就减
        if(pre<now){
            sum -= pre;
        }else{
            sum += pre;
        }
        pre = now;
    }
    return sum+now;
}

public int getVal(char s){
    switch(s){
        case 'I': return 1;
        case 'V': return 5;
        case 'X': return 10;
        case 'L': return 50;
        case 'C': return 100;
        case 'D': return 500;
        case 'M': return 1000;
    }
    return -1;
}
```

## 二叉树的最大深度 leetcode.104

```java
// 递归,左树的最大深度和右树的最大深度取最大,然后+1
public int maxDepth(TreeNode root) {
    if(root==null){return 0;}
    return Math.max(maxDepth(root.left), maxDepth(root.right))+1;
}
```


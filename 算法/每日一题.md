# 2023/10/3

## 回文数 leetcode.9

https://leetcode.cn/problems/palindrome-number/description/

思路: 一位数一位数的倒转,直到倒转的部分比前半部分大,进行比较

```java
class Solution {
    public boolean isPalindrome(int x) {
        if(x<0 || (x%10 == 0 && x!=0)) return false;
        int r = 0;
        while(r<x){
            r = r*10+x%10;
            x = x/10;
        }
        return x==r || x==r/10;
    }
}
```

## 合并数组 leetcode.88

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

思路: 正向不好操作,可以反向遍历,判断哪一位能被放进最后一位

```java
// 自己的写法
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        m--;n--;
        int k = m+n+1;
        while(n>=0){
            int b = nums2[n];
            if(m<0){
                nums1[k] = b;
                n--;
            }else{
                int a = nums1[m];
                if(a > b){
                    nums1[k] = a;
                    m--;
                }else{
                    nums1[k] = b;
                    n--;
                }
            }
            k--;
        }
    }
}

// 题解的写法
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        m--;n--;
        int k = m+n+1;
        while(n>=0){
            // 使用while可以减少判断次数,因为数组是有序的
            while(m>=0 && nums1[m]>nums2[n]){
                nums1[k--] = nums1[m--];continue;
            }
            nums1[k--] = nums2[n--];
        }
    }
}
```

# 2023/10/4

## 原地删除元素 leetcode.27

给定一个数组和待删除的值,要求使用O(1) 的额外空间删除元素

思路: 双指针，一前一后进行遍历，右指针可以用for遍历，左右指针的命名可以用left，right而不是i，j可读性高

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        // // 两个指针遍历数组
        // int i=0,j=0;
        // int n = nums.length;
        // while(i<n){
        //     if(nums[i]!=val){
        //         nums[j++] = nums[i++];
        //     }else{
        //         i++;
        //     }
        // }
        // return j;
        int left = 0;
        for(int right=0;right<nums.length;right++){
            if(nums[right] != val){
                nums[left++] = nums[right];
            }
        }
        return left;
    }
}
```

## 删除重复元素 leetcode.26

非递减数组中删除重复元素，使用原地算法，这里重复的必定相邻，返回删除后数组的长度

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int left=0,flag=nums[0];
        // 双指针遍历数组
        for(int right=0;right<nums.length;right++){
            int n = nums[right];
            if(n != flag){
                // 原思路: 不相等时就将右赋值给左
                // nums[++left] = n;
                // flag = n;
                // 优化: 两个数据相邻时就不复制
                if(right-left>1){
                    nums[++left] = n;
                }else{
                    left++;
                }
                flag = n;
            }
        }
        return left+1;
    }
}
```

# 2023/10/5

## 删除重复元素2 leetcode.80

给你一个有序数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使得出现次数超过两次的元素**只出现两次** ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

思路: 使用双指针，

题解: 

```java
public int removeDuplicates(int[] nums) {
    int n = nums.length;
    if(n<2) return n;
    // 删除重复元素,让一个元素最多出现两次
    int left=2;
    for(int right=2;right<n;right++){
        // 当左指针的前面两位和右指针指向的不相同时就可以赋值
        if(nums[left-2] != nums[right]){
            nums[left++] = nums[right];
        }
    }
    return left;
}
```

## 多数元素 leetcode.169

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

解法一:

遍历数组并将所有的结果存储到hash表中

```java
public int majorityElement(int[] nums) {
    int n = nums.length;
    int m = n/2;

    HashMap<Integer, Integer> map = new HashMap<>();

    for(int num:nums){
        map.put(num,map.getOrDefault(num,0)+1);
    }
    Stream<Map.Entry<Integer, Integer>> sorted = map.entrySet( ).stream( ).sorted(
        (entry1,entry2)-> -entry1.getValue().compareTo(entry2.getValue())
    );

    return sorted.collect(Collectors.toList()).get(0).getKey();
}
```

解法二:

```java
public int majorityElement(int[] nums) {
    int count=0,log=nums[0];
    // log为候选众数,当前遍历的数与他相等时,count+1,不等时count-1,count=0时换数
    for(int num:nums){
        if(count==0){
            log = num;
        }
        if(num==log){
            count++;
        }else{
            count--;
        }
    }
    return log;
}
```

证明: 

思路

如果我们把众数记为 +1+1+1，把其他数记为 −1-1−1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。

算法

Boyer-Moore 算法的本质和方法四中的分治十分类似。我们首先给出 Boyer-Moore 算法的详细步骤：

我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；

我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：

如果 x 与 candidate 相等，那么计数器 count 的值增加 1；

如果 x 与 candidate 不等，那么计数器 count 的值减少 1。

在遍历完成后，candidate 即为整个数组的众数。

我们举一个具体的例子，例如下面的这个数组：

[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
在遍历到数组中的第一个元素以及每个在 | 之后的元素时，candidate 都会因为 count 的值变为 0 而发生改变。最后一次 candidate 的值从 5 变为 7，也就是这个数组中的众数。

Boyer-Moore 算法的正确性较难证明，这里给出一种较为详细的用例子辅助证明的思路，供读者参考：

首先我们根据算法步骤中对 count 的定义，可以发现：在对整个数组进行遍历的过程中，count 的值一定非负。这是因为如果 count 的值为 0，那么在这一轮遍历的开始时刻，我们会将 x 的值赋予 candidate 并在接下来的一步中将 count 的值增加 1。因此 count 的值在遍历的过程中一直保持非负。

那么 count 本身除了计数器之外，还有什么更深层次的意义呢？我们还是以数组

[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
作为例子，首先写下它在每一步遍历时 candidate 和 count 的值：

nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
candidate:  7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7
count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4
我们再定义一个变量 value，它和真正的众数 maj 绑定。在每一步遍历时，如果当前的数 x 和 maj 相等，那么 value 的值加 1，否则减 1。value 的实际意义即为：到当前的这一步遍历为止，众数出现的次数比非众数多出了多少次。我们将 value 的值也写在下方：

nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4
有没有发现什么？我们将 count 和 value 放在一起：

nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4
value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4
发现在每一步遍历中，count 和 value 要么相等，要么互为相反数！并且在候选众数 candidate 就是 maj 时，它们相等，candidate 是其它的数时，它们互为相反数！

为什么会有这么奇妙的性质呢？这并不难证明：我们将候选众数 candidate 保持不变的连续的遍历称为「一段」。在同一段中，count 的值是根据 candidate == x 的判断进行加减的。那么如果 candidate 恰好为 maj，那么在这一段中，count 和 value 的变化是同步的；如果 candidate 不为 maj，那么在这一段中 count 和 value 的变化是相反的。因此就有了这样一个奇妙的性质。

这样以来，由于：

我们证明了 count 的值一直为非负，在最后一步遍历结束后也是如此；

由于 value 的值与真正的众数 maj 绑定，并且它表示「众数出现的次数比非众数多出了多少次」，那么在最后一步遍历结束后，value 的值为正数；

在最后一步遍历结束后，count 非负，value 为正数，所以它们不可能互为相反数，只可能相等，即 count == value。因此在最后「一段」中，count 的 value 的变化是同步的，也就是说，candidate 中存储的候选众数就是真正的众数 maj。

Java
Python3
C++
class Solution {
    public int majorityElement(int[] nums) {
        int count = 0;
        Integer candidate = null;

        for (int num : nums) {
            if (count == 0) {
                candidate = num;
            }
            count += (num == candidate) ? 1 : -1;
        }
    
        return candidate;
    }

链接：https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/

# 2023/10/6

## 轮转数组 leetcode.189

数组内所有元素循环向右移动k位

```java
public void rotate(int[] nums, int k) {
    // 1.使用额外的数组存储
    // int n = nums.length;
    // k = k%n;
    // if(k==0) return;
    // int[] newNums = new int[n];
    // int i=0;
    // do{
    //     newNums[k] = nums[i];
    //     k = (k+1)%n;
    //     i++;
    // }while(i!=n);
    // System.arraycopy(newNums,0,nums,0,n);
    
    // 2.循环轮转, 第0位的元素移动到0+k处,0+k处的元素移动到0+2k处
    // int n = nums.length;
    // k = k%n;
    // if(k==0) return;
    // int count=0,start=0;
    // while(count!=n){
    //     int i=start;
    //     int temp = nums[i];
    //     do{
    //         count++;
    //         i = (i+k)%n;
    //         temp = nums[i]+temp;
    //         nums[i] = temp-nums[i];
    //         temp = temp-nums[i];
    //     }while(i!=start);
    //     start++;
    // }

    // 3.数组翻转, 先整体翻转,再分别翻转前后半部分
    int n = nums.length;
    k = k%n;
    reverse(nums, 0, n-1);
    reverse(nums, 0, k-1);
    reverse(nums, k, n-1);
}
public void reverse(int nums[], int start, int end){
    while(start<end){
        int temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
        start++;end--;
    }
}
```

## 买卖股票的最佳时机 leetcode.121

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

```java
public int maxProfit(int[] prices) {
    // 记录最小值
    int min=prices[0];
    // 记录最大利润
    int lr = 0;
    for(int num: prices){
        // 始终记录历史最低点
        min = Math.min(min,num);
        // 当前的最小值和当前天的相差的利润谁最大
        lr = Math.max(lr,num-min);
    }
    return lr;
}
```

# 2023/10/7

## 买卖股票的最佳时机 leetcode.122

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

思路: 动态规划，二维数组dp[i][j]表示第i天持股状态为j时的最大现金数，当后续状态只和前一个状态有关时，可以使用滚动变量来节省空间

```java
public int maxProfit(int[] prices) {
    int n = prices.length;
    if(n<2){
        return 0;
    }
    // // 二维数组dp[i][j]表示第i天持股状态为j时的最大现金数
    // int[][] dp = new int[n][2];
    // // 第一天若不持有股票则有0元
    // dp[0][0] = 0;
    // // 若持有股票则有-prices[0]元
    // dp[0][1] = -prices[0];
    // for(int i=1;i<n;i++){
    //     // 这一天的钱为,原先持有股票卖出,或者原先不持有股票
    //     dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i]);
    //     // 这一天持股为,原先就持有,或者原先没有,今天买入
    //     dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-prices[i]);
    // }
    // return dp[n-1][0];
    // 用滚动变量节省空间
    int cash=0,hold=-prices[0];
    int preCash,preHold;
    for(int i=1;i<n;i++){
        preCash = cash;preHold = hold;
        cash = Math.max(preCash, preHold+prices[i]);
        hold = Math.max(preHold, preCash-prices[i]);
    }
    return cash;
}
```

## 跳跃游戏 leetcode.55

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

本质也是动态规划的思想

dp[i]代表走到i位时最大可以调到的位置

dp[i] = max(dp[i-1], i+nums[i]);

进行空间优化,dp[]变成一个变量max

```java
public boolean canJump(int[] nums) {
    int n = nums.length;
    if(n<2) return true;
    // 初始最远可以跳到哪里
    int max = nums[0];
    for(int i=0;i<max+1;i++){
        // 当前位置加上当前格子的最远可以跳到的位置,和原本最远可以跳到的位置取最大
        max = Math.max(i+nums[i],max);
        if(max>=n-1) return true;
    }
    return false;
}
```

# 2023/10/8

## 跳跃游戏2 leetcode.45

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

思路: 使用变量记录步数和当前步能到达的最远处,过了这个最远处就是下一步的了

 ```java
public int jump(int[] nums) {
    int n = nums.length;
    if(n<2) return 0;
    int jump = 0;
    // 最远可以跳到哪里
    int max = 0;
    // 这一步最远可以跳到哪里
    int stepMax = nums[0];
    for(int i=0;i<n-1;i++){
        // 当前位置加上当前格子的最远可以跳到的位置,和原本最远可以跳到的位置取最大
        max = Math.max(i+nums[i],max);
        // 跳到了当前步的最远处,更新步数和当前步的最远处
        if(i==stepMax){
            stepMax = max;
            jump++;
        }
    }
    return jump;
}
 ```

## H指数 leetcode.274

给你一个整数数组 `citations` ，其中 `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数。计算并返回该研究者的 **`h` 指数**。

根据维基百科上 [h 指数的定义](https://baike.baidu.com/item/h-index/3991452?fr=aladdin)：`h` 代表“高引用次数” ，一名科研人员的 `h` **指数** 是指他（她）至少发表了 `h` 篇论文，并且每篇论文 **至少** 被引用 `h` 次。如果 `h` 有多种可能的值，**`h` 指数** 是其中最大的那个。

```java
public int hIndex(int[] citations) {
    // 思路1: 计数统计
    // 被引用大于h的都算在nums[h]内
    // 要找最大的nums[h] >= h

    // int n = citations.length;
    // int[] nums = new int[n+1];
    // for(int i=0;i<n;i++){
    //     for(int j=0;j<=Math.min(n,citations[i]);j++){ nums[j]++;}
    // }
    // for(int j=n;j>=0;j--){
    //     if(nums[j]>=j) return j;
    // }
    // return 0;
    
    // 思路2: 排序
    Arrays.sort(citations);
    int j = citations.length-1;
    int h=0;
    // 从大到小遍历,当前遍历的值(引用次数)比记录的h大,则h+1
    while(j>=0 && citations[j]>h){
        h++;
        j--;
    }
    return h;
}
```

# 2023/10/9

## O(1)时间插入删除获取随机元素 leetcode.380


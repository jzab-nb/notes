# 	2023/10/3

## 回文数 leetcode.9

https://leetcode.cn/problems/palindrome-number/description/

思路: 一位数一位数的倒转,直到倒转的部分比前半部分大,进行比较

```java
class Solution {
    public boolean isPalindrome(int x) {
        if(x<0 || (x%10 == 0 && x!=0)) return false;
        int r = 0;
        while(r<x){
            r = r*10+x%10;
            x = x/10;
        }
        return x==r || x==r/10;
    }
}
```

## 合并数组 leetcode.88

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

思路: 正向不好操作,可以反向遍历,判断哪一位能被放进最后一位

```java
// 自己的写法
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        m--;n--;
        int k = m+n+1;
        while(n>=0){
            int b = nums2[n];
            if(m<0){
                nums1[k] = b;
                n--;
            }else{
                int a = nums1[m];
                if(a > b){
                    nums1[k] = a;
                    m--;
                }else{
                    nums1[k] = b;
                    n--;
                }
            }
            k--;
        }
    }
}

// 题解的写法
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        m--;n--;
        int k = m+n+1;
        while(n>=0){
            // 使用while可以减少判断次数,因为数组是有序的
            while(m>=0 && nums1[m]>nums2[n]){
                nums1[k--] = nums1[m--];continue;
            }
            nums1[k--] = nums2[n--];
        }
    }
}
```

# 2023/10/4

## 原地删除元素 leetcode.27

给定一个数组和待删除的值,要求使用O(1) 的额外空间删除元素

思路: 双指针，一前一后进行遍历，右指针可以用for遍历，左右指针的命名可以用left，right而不是i，j可读性高

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        // // 两个指针遍历数组
        // int i=0,j=0;
        // int n = nums.length;
        // while(i<n){
        //     if(nums[i]!=val){
        //         nums[j++] = nums[i++];
        //     }else{
        //         i++;
        //     }
        // }
        // return j;
        int left = 0;
        for(int right=0;right<nums.length;right++){
            if(nums[right] != val){
                nums[left++] = nums[right];
            }
        }
        return left;
    }
}
```

## 删除重复元素 leetcode.26

非递减数组中删除重复元素，使用原地算法，这里重复的必定相邻，返回删除后数组的长度

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int left=0,flag=nums[0];
        // 双指针遍历数组
        for(int right=0;right<nums.length;right++){
            int n = nums[right];
            if(n != flag){
                // 原思路: 不相等时就将右赋值给左
                // nums[++left] = n;
                // flag = n;
                // 优化: 两个数据相邻时就不复制
                if(right-left>1){
                    nums[++left] = n;
                }else{
                    left++;
                }
                flag = n;
            }
        }
        return left+1;
    }
}
```

# 2023/10/5

## 删除重复元素2 leetcode.80

给你一个有序数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使得出现次数超过两次的元素**只出现两次** ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

思路: 使用双指针，

题解: 

```java
public int removeDuplicates(int[] nums) {
    int n = nums.length;
    if(n<2) return n;
    // 删除重复元素,让一个元素最多出现两次
    int left=2;
    for(int right=2;right<n;right++){
        // 当左指针的前面两位和右指针指向的不相同时就可以赋值
        if(nums[left-2] != nums[right]){
            nums[left++] = nums[right];
        }
    }
    return left;
}
```

## 多数元素 leetcode.169

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

解法一:

遍历数组并将所有的结果存储到hash表中

```java
public int majorityElement(int[] nums) {
    int n = nums.length;
    int m = n/2;

    HashMap<Integer, Integer> map = new HashMap<>();

    for(int num:nums){
        map.put(num,map.getOrDefault(num,0)+1);
    }
    Stream<Map.Entry<Integer, Integer>> sorted = map.entrySet( ).stream( ).sorted(
        (entry1,entry2)-> -entry1.getValue().compareTo(entry2.getValue())
    );

    return sorted.collect(Collectors.toList()).get(0).getKey();
}
```

解法二:

```java
public int majorityElement(int[] nums) {
    int count=0,log=nums[0];
    // log为候选众数,当前遍历的数与他相等时,count+1,不等时count-1,count=0时换数
    for(int num:nums){
        if(count==0){
            log = num;
        }
        if(num==log){
            count++;
        }else{
            count--;
        }
    }
    return log;
}
```

证明: 

思路

如果我们把众数记为 +1+1+1，把其他数记为 −1-1−1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。

算法

Boyer-Moore 算法的本质和方法四中的分治十分类似。我们首先给出 Boyer-Moore 算法的详细步骤：

我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；

我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：

如果 x 与 candidate 相等，那么计数器 count 的值增加 1；

如果 x 与 candidate 不等，那么计数器 count 的值减少 1。

在遍历完成后，candidate 即为整个数组的众数。

我们举一个具体的例子，例如下面的这个数组：

[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
在遍历到数组中的第一个元素以及每个在 | 之后的元素时，candidate 都会因为 count 的值变为 0 而发生改变。最后一次 candidate 的值从 5 变为 7，也就是这个数组中的众数。

Boyer-Moore 算法的正确性较难证明，这里给出一种较为详细的用例子辅助证明的思路，供读者参考：

首先我们根据算法步骤中对 count 的定义，可以发现：在对整个数组进行遍历的过程中，count 的值一定非负。这是因为如果 count 的值为 0，那么在这一轮遍历的开始时刻，我们会将 x 的值赋予 candidate 并在接下来的一步中将 count 的值增加 1。因此 count 的值在遍历的过程中一直保持非负。

那么 count 本身除了计数器之外，还有什么更深层次的意义呢？我们还是以数组

[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
作为例子，首先写下它在每一步遍历时 candidate 和 count 的值：

nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
candidate:  7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7
count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4
我们再定义一个变量 value，它和真正的众数 maj 绑定。在每一步遍历时，如果当前的数 x 和 maj 相等，那么 value 的值加 1，否则减 1。value 的实际意义即为：到当前的这一步遍历为止，众数出现的次数比非众数多出了多少次。我们将 value 的值也写在下方：

nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4
有没有发现什么？我们将 count 和 value 放在一起：

nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4
value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4
发现在每一步遍历中，count 和 value 要么相等，要么互为相反数！并且在候选众数 candidate 就是 maj 时，它们相等，candidate 是其它的数时，它们互为相反数！

为什么会有这么奇妙的性质呢？这并不难证明：我们将候选众数 candidate 保持不变的连续的遍历称为「一段」。在同一段中，count 的值是根据 candidate == x 的判断进行加减的。那么如果 candidate 恰好为 maj，那么在这一段中，count 和 value 的变化是同步的；如果 candidate 不为 maj，那么在这一段中 count 和 value 的变化是相反的。因此就有了这样一个奇妙的性质。

这样以来，由于：

我们证明了 count 的值一直为非负，在最后一步遍历结束后也是如此；

由于 value 的值与真正的众数 maj 绑定，并且它表示「众数出现的次数比非众数多出了多少次」，那么在最后一步遍历结束后，value 的值为正数；

在最后一步遍历结束后，count 非负，value 为正数，所以它们不可能互为相反数，只可能相等，即 count == value。因此在最后「一段」中，count 的 value 的变化是同步的，也就是说，candidate 中存储的候选众数就是真正的众数 maj。

Java
Python3
C++
class Solution {
    public int majorityElement(int[] nums) {
        int count = 0;
        Integer candidate = null;

        for (int num : nums) {
            if (count == 0) {
                candidate = num;
            }
            count += (num == candidate) ? 1 : -1;
        }
    
        return candidate;
    }

链接：https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/

# 2023/10/6

## 轮转数组 leetcode.189

数组内所有元素循环向右移动k位

```java
public void rotate(int[] nums, int k) {
    // 1.使用额外的数组存储
    // int n = nums.length;
    // k = k%n;
    // if(k==0) return;
    // int[] newNums = new int[n];
    // int i=0;
    // do{
    //     newNums[k] = nums[i];
    //     k = (k+1)%n;
    //     i++;
    // }while(i!=n);
    // System.arraycopy(newNums,0,nums,0,n);
    
    // 2.循环轮转, 第0位的元素移动到0+k处,0+k处的元素移动到0+2k处
    // int n = nums.length;
    // k = k%n;
    // if(k==0) return;
    // int count=0,start=0;
    // while(count!=n){
    //     int i=start;
    //     int temp = nums[i];
    //     do{
    //         count++;
    //         i = (i+k)%n;
    //         temp = nums[i]+temp;
    //         nums[i] = temp-nums[i];
    //         temp = temp-nums[i];
    //     }while(i!=start);
    //     start++;
    // }

    // 3.数组翻转, 先整体翻转,再分别翻转前后半部分
    int n = nums.length;
    k = k%n;
    reverse(nums, 0, n-1);
    reverse(nums, 0, k-1);
    reverse(nums, k, n-1);
}
public void reverse(int nums[], int start, int end){
    while(start<end){
        int temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
        start++;end--;
    }
}
```

## 买卖股票的最佳时机 leetcode.121

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

```java
public int maxProfit(int[] prices) {
    // 记录最小值
    int min=prices[0];
    // 记录最大利润
    int lr = 0;
    for(int num: prices){
        // 始终记录历史最低点
        min = Math.min(min,num);
        // 当前的最小值和当前天的相差的利润谁最大
        lr = Math.max(lr,num-min);
    }
    return lr;
}
```

# 2023/10/7

## 买卖股票的最佳时机 leetcode.122

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

思路: 动态规划，二维数组dp[i][j]表示第i天持股状态为j时的最大现金数，当后续状态只和前一个状态有关时，可以使用滚动变量来节省空间

```java
public int maxProfit(int[] prices) {
    int n = prices.length;
    if(n<2){
        return 0;
    }
    // // 二维数组dp[i][j]表示第i天持股状态为j时的最大现金数
    // int[][] dp = new int[n][2];
    // // 第一天若不持有股票则有0元
    // dp[0][0] = 0;
    // // 若持有股票则有-prices[0]元
    // dp[0][1] = -prices[0];
    // for(int i=1;i<n;i++){
    //     // 这一天的钱为,原先持有股票卖出,或者原先不持有股票
    //     dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i]);
    //     // 这一天持股为,原先就持有,或者原先没有,今天买入
    //     dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-prices[i]);
    // }
    // return dp[n-1][0];
    // 用滚动变量节省空间
    int cash=0,hold=-prices[0];
    int preCash,preHold;
    for(int i=1;i<n;i++){
        preCash = cash;preHold = hold;
        cash = Math.max(preCash, preHold+prices[i]);
        hold = Math.max(preHold, preCash-prices[i]);
    }
    return cash;
}
```

## 跳跃游戏 leetcode.55

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

本质也是动态规划的思想

dp[i]代表走到i位时最大可以调到的位置

dp[i] = max(dp[i-1], i+nums[i]);

进行空间优化,dp[]变成一个变量max

```java
public boolean canJump(int[] nums) {
    int n = nums.length;
    if(n<2) return true;
    // 初始最远可以跳到哪里
    int max = nums[0];
    for(int i=0;i<max+1;i++){
        // 当前位置加上当前格子的最远可以跳到的位置,和原本最远可以跳到的位置取最大
        max = Math.max(i+nums[i],max);
        if(max>=n-1) return true;
    }
    return false;
}
```

# 2023/10/8

## 跳跃游戏2 leetcode.45

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

思路: 使用变量记录步数和当前步能到达的最远处,过了这个最远处就是下一步的了

 ```java
public int jump(int[] nums) {
    int n = nums.length;
    if(n<2) return 0;
    int jump = 0;
    // 最远可以跳到哪里
    int max = 0;
    // 这一步最远可以跳到哪里
    int stepMax = nums[0];
    for(int i=0;i<n-1;i++){
        // 当前位置加上当前格子的最远可以跳到的位置,和原本最远可以跳到的位置取最大
        max = Math.max(i+nums[i],max);
        // 跳到了当前步的最远处,更新步数和当前步的最远处
        if(i==stepMax){
            stepMax = max;
            jump++;
        }
    }
    return jump;
}
 ```

## H指数 leetcode.274

给你一个整数数组 `citations` ，其中 `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数。计算并返回该研究者的 **`h` 指数**。

根据维基百科上 [h 指数的定义](https://baike.baidu.com/item/h-index/3991452?fr=aladdin)：`h` 代表“高引用次数” ，一名科研人员的 `h` **指数** 是指他（她）至少发表了 `h` 篇论文，并且每篇论文 **至少** 被引用 `h` 次。如果 `h` 有多种可能的值，**`h` 指数** 是其中最大的那个。

```java
public int hIndex(int[] citations) {
    // 思路1: 计数统计
    // 被引用大于h的都算在nums[h]内
    // 要找最大的nums[h] >= h

    // int n = citations.length;
    // int[] nums = new int[n+1];
    // for(int i=0;i<n;i++){
    //     for(int j=0;j<=Math.min(n,citations[i]);j++){ nums[j]++;}
    // }
    // for(int j=n;j>=0;j--){
    //     if(nums[j]>=j) return j;
    // }
    // return 0;
    
    // 思路2: 排序
    Arrays.sort(citations);
    int j = citations.length-1;
    int h=0;
    // 从大到小遍历,当前遍历的值(引用次数)比记录的h大,则h+1
    while(j>=0 && citations[j]>h){
        h++;
        j--;
    }
    return h;
}
```

# 2023/10/9

## O(1)时间插入删除获取随机元素 leetcode.380

o(1)时间复杂度需要用哈希表来实现

```java
class RandomizedSet {

    Set<Integer> set;
    Random r;

    public RandomizedSet() {
        set = new HashSet<>();
        r = new Random();
    }
    
    public boolean insert(int val) {
        if(!set.contains(val)){
            set.add(val);
            return true;
        }else{
            return false;
        }
    }
    
    public boolean remove(int val) {
        if(set.contains(val)){
            set.remove(val);
            return true;
        }else{
            return false;
        }
    }
    
    public int getRandom() {
        ArrayList<Integer> a = new ArrayList<Integer>(set);
        return a.get(r.nextInt(0,a.size()));
    }
}
```

## 除自身以外数组的乘积 leetcode.238

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] r = new int[n];
        // 1.借助两个数组存储左乘积和右乘积
        // int[] left = new int[n];
        // int[] right = new int[n];
        // left[0] = 1;
        // right[n-1] = 1;
        // int i=1,j=n-2;
        // while(i<n && j>=0){
        //     left[i] = left[i-1]*nums[i-1];
        //     right[j] = right[j+1]*nums[j+1];
        //     i++;j--;
        // }
        
        // for(i=0;i<n;i++){
        //     r[i] = left[i]*right[i];
        // }

        // 2.直接用返回数组存左前缀
        r[0] = 1;
        // 先把每个表的左面元素的乘积记录下来
        for(int i=1;i<n;i++){
            r[i] = r[i-1] * nums[i-1];
        }
        int right = 1;
        // 写入结果
        for(int j=n-1;j>=0;j--){
            r[j] = r[j] * right;
            right = right*nums[j];
        }
        return r;
    }
}
```

# 2023/10/10

## 加油站 leetcode.134

在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。

![image-20231010163842649](%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98.assets/image-20231010163842649.png)

思路: 用折线表示油箱内的油，以油最少的时刻作为起点

```java
public int canCompleteCircuit(int[] gas, int[] cost) {
    int sum = 0;
    int min = Integer.MAX_VALUE;
    int mini = 0;
    for(int i=0;i<gas.length;i++){
        sum = sum+(gas[i]-cost[i]);
       	// 现在计算的其实是i+1的折线点
        if(sum<min){
            mini = i;
            min = sum;
        }
    }
    // 折线的最底端大于等于0,则从0开始即可
    if(min>=0) return 0;
    return sum<0?-1:(mini+1)%gas.length;
}
```

## 分发糖果 leetcode.135

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

思路: 分两次遍历，先判断一个孩子和他左面的谁大，大的应该要比左面的拿到的多一个

第二次遍历，大的应该要比他右面的拿到的多一个，最终两个值取最大

```java
public int candy(int[] ratings) {
    int n = ratings.length;
    int[] left = new int[n];
    int right,sum;
    // 右不用数组,一个变量累计
    right = 1;
    left[0] = 1;
    for(int i=1;i<n;i++){
        left[i] = ratings[i]>ratings[i-1]?left[i-1]+1:1;
    }
    sum = Math.max(right,left[n-1]);
    for(int j=n-2;j>=0;j--){
        right = ratings[j]>ratings[j+1]?right+1:1;
        sum += Math.max(left[j],right);
    }
    return sum;
}
```

# 2023/10/11

## 接雨水 leetcode.42

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

 

**示例 1：**

![img](%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98.assets/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

思路一:

按行遍历，先遍历第一行，左右比大当前行高就可以存水，一直到最高一行

```java
int len=Arrays.stream(height).max().getAsInt(),h=0, sum=0;
int n = height.length;
while(h<len){
    Integer left=null;
    // 遍历一层
    for(int i=0;i<n;i++){
        if(height[i] > h){
            if(left!=null){
                sum += i-left-1;
            }
            left = i;
        }
    }
    h++;
}
return sum;
```

思路二:

按列遍历,找一列左边最高的墙和右边最高的墙,这两个里面小的一方跟当前列的高度比较

```java
int n = height.length;
int sum = 0;
for(int i=1;i<n-1;i++){
    int maxLeft = Integer.MIN_VALUE;
    int maxRight = Integer.MIN_VALUE;
    for(int k=0;k<i;k++){
        maxLeft = Math.max(maxLeft, height[k]);
    }
    for(int k=i+1;k<n;k++){
        maxRight = Math.max(maxRight, height[k]);
    }
    int min = Math.min(maxLeft,maxRight);
    if(min>height[i]){
        sum += min-height[i];
    }
}
return sum;
```

思路三:

动态规划,左边最高的和右边最高的记录为数组

```java
int n = height.length;
int sum = 0;
int left[] = new int[n];
int right[] = new int[n];
left[0] = 0;right[n-1] = 0;
for(int i=1;i<n;i++){
    left[i] = Math.max(height[i-1],left[i-1]);
}
for(int i=n-2;i>=0;i--){
    right[i] = Math.max(height[i+1],right[i+1]);
}
for(int i=1;i<n-1;i++){
    int min = Math.min(left[i], right[i]);
    if(min>height[i]){
        sum += min-height[i];
    }
}
return sum;
```

## 罗马数字转整数 leetcode.13

罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 1 。`12` 写做 `XII` ，即为 `X` + `II` 。 `27` 写做 `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。

```java
public int romanToInt(String s) {
    // 左<右则结果减左,否则加左
    // s.charAt();

    int sum=0;
    int pre = getVal(s.charAt(0));
    // 长度为1时直接返回now,也就是第一位
    int now=pre;
    for(int i=1;i<s.length();i++){
        now = getVal(s.charAt(i));
        // 当前位和前一位比较,前一位小的话就减
        if(pre<now){
            sum -= pre;
        }else{
            sum += pre;
        }
        pre = now;
    }
    return sum+now;
}

public int getVal(char s){
    switch(s){
        case 'I': return 1;
        case 'V': return 5;
        case 'X': return 10;
        case 'L': return 50;
        case 'C': return 100;
        case 'D': return 500;
        case 'M': return 1000;
    }
    return -1;
}
```

## 二叉树的最大深度 leetcode.104

```java
// 递归,左树的最大深度和右树的最大深度取最大,然后+1
public int maxDepth(TreeNode root) {
    if(root==null){return 0;}
    return Math.max(maxDepth(root.left), maxDepth(root.right))+1;
}
```

# 2023/10/12

## 整数转罗马数字 leetcode.12

思路: 把所有单字母和双字母后-前的组合列出来,从大到小遍历即可

```java
public String intToRoman(int num) {
    int[] k = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    String[] v = {"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
    StringBuffer r = new StringBuffer();
    int i=0;
    while(i<13){
        if(k[i]<=num){
            num-=k[i];
            r.append(v[i]);
        }else{
            i++;
        }
    }
    return r.toString();
}
```

## 最后一个单词的长度 leetcode.58

思路: 从后向前遍历,找到第一个字母开始计数,碰到空格或者走到最后则返回

```java
public int lengthOfLastWord(String s) {
    int i = s.length()-1;
    int start = 0;
    while(i>=0){
        char c = s.charAt(i);
        if(c!=' '){
            start++;
        }else{
            if(start!=0) break;
        }
        i--;
    }
    return start;
}
```

## 删除链表的倒数第n个节点

思路: 快慢指针, 哑节点简化头结点的特殊操作

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    // 定义哑节点,放在头结点之前
    ListNode ya = new ListNode();
    ya.next = head;
    // 快指针从头节点开始
    ListNode quick = head;
    // 慢指针从哑节点开始
    ListNode slow = ya;
    // 快指针先向前走n个
    while(n>0){
        quick = quick.next;
        n--;
    }
    // 快慢同时向前,直到快指向空,这时慢正好指向要删除的前一个
    while(quick!=null){
        quick = quick.next;
        slow = slow.next;
    }
    // 删除节点
    slow.next = slow.next.next;
    // 返回头结点(可能为空),所以是哑节点的下一个
    return ya.next;
}
```

# 2023/10/13

## 最长公共前缀 leetcode.14

给定一个字符串数组，找出数组中所有字符串的最长公共前缀

```java
public String longestCommonPrefix(String[] strs) {
    int n = strs.length;
    if(n==0) return "";
    if(n==1) return strs[0];
    // 最长公共前缀初始化为第一个字符串
    String max = strs[0];
    // 遍历整个数组
    for(int i=1;i<n;i++){
        String now = strs[i];
        // 每一个都和max比较,找出最长公共前缀
        int j;
        // 循环每一个字符
        for(j=0;j<Math.min(now.length(),max.length());j++){
            // 遍历到不相等的了, 若长度为0了则返回空字符串, 否则跳出循环
            if(now.charAt(j)!=max.charAt(j)){
                if(j==0) return "";
                else break;
            }
        }
        // 对前缀进行切割,只可能短,不可能长
        max = max.substring(0,j);
    }
    return max;
}
```

## 反转字符串中的单词 leetcode.151

给定一个字符串，去掉多余的空格，单词顺序反转

思路: 熟练使用工具类

字符串.trim() 去除左右的空格

Collections.reverse() 集合逆序

String.join(" ", 集合) 字符串拼接

```java
public String reverseWords(String s) {
    // String s = " 123 456 ";
    s = s.trim();
    List<String> split = Arrays.asList(s.split("\\s+"));
    Collections.reverse(split);
    return String.join(" ", split);
}
```



## N字形变换 leetcode.6

将一个给定字符串 `s` 根据给定的行数 `numRows` ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 `"PAYPALISHIRING"` 行数为 `3` 时，排列如下：

```
P   A   H   N
A P L S I I G
Y   I   R
```

之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`"PAHNAPLSIIGYIR"`。

请你实现这个将字符串进行指定行数变换的函数：

```
string convert(string s, int numRows);
```

 

**示例 1：**

```
输入：s = "PAYPALISHIRING", numRows = 3
输出："PAHNAPLSIIGYIR"
```

**示例 2：**

```
输入：s = "PAYPALISHIRING", numRows = 4
输出："PINALSIGYAHRPI"
解释：
P     I    N
A   L S  I G
Y A   H R
P     I
```

**示例 3：**

```
输入：s = "A", numRows = 1
输出："A"
```

 思路: 根据规律推导公式

根据图形，图像可以按块分开，一个块的大小为(2numRows-2)，一个块又可分成左边竖着的一列（n）和斜着的（n-2）

遍历块里的行，针对每一行，遍历所有的块，对于第二行开始的行，要考虑右边斜着的位置是否有元素

右边斜着的位置在块里的下标为j，行的下标为i则，j = size-i（size为块大小2n-2）

```java
public String convert(String s, int numRows) {
    if(numRows == 1) return s;
    // 一个块的大小: 2n-2
    // 3+1
    // 4+2
    // 5+3
    // ...
    // j = size-i
    // 2 = 6-2
    StringBuffer sb = new StringBuffer();
    int len = s.length();
    int size = 2*numRows-2;
    // i是在一个块中的序号
    for(int i=0;i<numRows;i++){
        // n是第几个块
        int n=0;
        while(size*n+i<len){
            sb.append(s.charAt(size*n+i));
            // 中间的几行
            if(i>0 && i<numRows-1 && size*n+size-i<len){
                sb.append(s.charAt(size*n+size-i));
            }
            n++;
        }
    }
    return sb.toString();
}
```

# 2023/10/14

## 找出字符串中第一个匹配项的下标 leetcode.28

思路: KMP算法 [视频教程地址](https://www.bilibili.com/video/BV1AY4y157yL)

```java
class Solution {
    public int strStr(String haystack, String needle) {
        int[] next = buildNext(needle);
        int i=0;int j=0;
        while(i<haystack.length() && j<haystack.length()){
            if(haystack.charAt(i) == needle.charAt(j)){
                i++;j++;
            }else if(j>0){
                j = next[j-1];
            }else{
                i++;
            }
            if(j>=needle.length()) return i-j;
        }
        return -1;
    }

    public int[] buildNext(String s){
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        // 相同前后缀的长度
        int prefix_len = 0;
        int i = 1;
        while(i < n){
            // 前缀的下一个和当前的元素相同,则相同前后缀长度+1
            if(s.charAt(prefix_len) == s.charAt(i)){
                prefix_len++;
                // next数组对应位置为相同前后缀的长度
                next[i++] = prefix_len;
            }else{
                // 相同前后缀长度为0,则更新数组
                if(prefix_len == 0){
                    next[i++] = 0;
                }else{
                    // 相同前后缀长度不为0,则在左边寻找相同前后缀
                    prefix_len = next[prefix_len - 1];
                }
            }
        }
        return next;
    }
}
```

# 2023/10/15

## 文本左右对齐 leetcode.68

给定一个单词数组和最大长度

要求进行排版: 

1. 文本左右对齐，空格尽量均匀分布，若无法均匀分布，则左边的空格要比右边的多
2. 若一行只有一个单词，则单词左对齐，右面填充空格
3. 若是最后一行，则左对齐，单词之间只填充一个空格

思路：

先统计每行需要多少个单词，再根据单词数和行数分三种情况进行判断：

1. 普通情况，计算空格数，和需要填充空格的位置，进而计算出每一个位置有多少个空格，左面几个需要填充额外的空格
2. 只有一个单词的情况，直接根据单词长度计算出空格长度进行填充
3. 最后一行，先放入第一个单词，第二个单词和后面的带着空格放入，然后计算还需要多少个空格在右面

优化: 字符串的拼接使用StringBuilder，可以从4ms优化到0ms

```java
public List<String> fullJustify(String[] words, int maxWidth) {
    // 统计每行放几个
    List<Integer> line = counts(words, maxWidth);
    List<String> result = new ArrayList<>();
    int lineSize = line.size();
    int k = 0;
    for(int i=0;i<lineSize;i++){
        int lineWordCount = line.get(i);
        if(lineWordCount==1){
            // 当前行只有一个单词,左对齐
            // 根据单词长度计算空格长度
            String s = words[k++];
            int blankLen = maxWidth - s.length();
            result.add(fillBlank(new StringBuilder(s), blankLen));
        }else if(i == lineSize-1){
            // 最后一行左对齐, 第一个单词放进去
            StringBuilder s = new StringBuilder(words[k++]);
            // 所有单词遍历出来(前面接空格)
            for(int temp=1;temp<lineWordCount;temp++) s.append(" ").append(words[k++]);
            // 填充空格
            int blankLen = maxWidth - s.length();
            result.add(fillBlank(s, blankLen));
        }else{
            // 一般情况, 尽可能均匀的分配空格,无法均匀分配的给左边
            // 先计算总的空格数 = 总长度-所有单词的字符长度
            int wordsLen = 0;
            for(int temp=0;temp<lineWordCount;temp++) wordsLen+=words[k+temp].length();
            int blankLen = maxWidth - wordsLen;
            // 再计算有几个地方需要填充空格 = 单词数目-1
            int blankPlaceNum = lineWordCount-1;
            // 空格数/需要填充的位置 = 每个位置需要填充几个
            int oneBlankNum = blankLen / blankPlaceNum;
            // 空格数%需要填充的位置 = 前几个位置需要多一个空格
            int moreCount = blankLen % blankPlaceNum;
            // 遍历填充
            StringBuilder s = new StringBuilder(words[k++]);
            for(int temp=1;temp<lineWordCount;temp++){
                if(moreCount-->0){
                    fillBlank(s, oneBlankNum+1);
                }else{
                    fillBlank(s, oneBlankNum);
                }
                s.append(words[k++]);
            }
            result.add(s.toString());
        }
    }
    return result;
}

public String fillBlank(StringBuilder s, int blankLen){
    for(int temp=0;temp<blankLen;temp++) s.append(" ");
    return s.toString();
}

public List<Integer> counts(String[] words, int maxWidth){
    // 先确定一行可以放几个单词
    List<Integer> line = new ArrayList<>();
    int count =0;
    int len = 0;
    for(int i=0;i<words.length;i++){
        if(len==0){
            // 当前行还未放入单词,则放入第一个单词
            len += words[i].length();
            count++;
        }else{
            // 否则放入后面的单词和一个空格
            len += 1+words[i].length();
            if(len>maxWidth){
                line.add(count);
                count = 0;
                len = 0;
                i--;
            }else{
                count++;
            }
        }
    }
    // 最后一行的加进来
    line.add(count);
    return line;
}
```

## 找出满足差值条件的下标 leetcode.100096

给你一个下标从 **0** 开始、长度为 `n` 的整数数组 `nums` ，以及整数 `indexDifference` 和整数 `valueDifference` 。

你的任务是从范围 `[0, n - 1]` 内找出 **2** 个满足下述所有条件的下标 `i` 和 `j` ：

- `abs(i - j) >= indexDifference` 且
- `abs(nums[i] - nums[j]) >= valueDifference`

返回整数数组 `answer`。如果存在满足题目要求的两个下标，则 `answer = [i, j]` ；否则，`answer = [-1, -1]` 。如果存在多组可供选择的下标对，只需要返回其中任意一组即可。

**注意：**`i` 和 `j` 可能 **相等** 。

思路: 直接暴力(有O(n)的算法,在: [链接](https://leetcode.cn/problems/find-indices-with-index-and-value-difference-i/solutions/2483162/on-zuo-fa-shuang-zhi-zhen-wei-hu-zui-da-rkbk9/))

```java
public int[] findIndices(int[] nums, int indexDifference, int valueDifference) {
    int[] r = {-1,-1};
    int len = nums.length;
    for(int i=0;i<len;i++){
        for(int j=0;j<len;j++){
            if(Math.abs(i-j) >= indexDifference && Math.abs(nums[i] - nums[j]) >= valueDifference){
                r[0] = i;
                r[1] = j;
                break;
            }
        }
    }
    return r;
}
```

## 验证回文串 leetcode.125

一个字符串中, 大小写字母(不分大小写)和数字部分符号回文即可

思路: 碰到不在考虑范围内的字符则跳过,左右指针都是要判断的字符再判断

```java
public boolean isPalindrome(String s) {
    // 首尾两个指针遍历
    int left=0,right = s.length()-1;
    while(left<right){
        if(!canJudge(s.charAt(left))) {left++;continue;}
        if(!canJudge(s.charAt(right))) {right--;continue;}
        if(Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) return false;
        left++;right--;
    }
    return true;
}

public boolean canJudge(char ch){
    return (ch>='a' && ch<='z') || (ch>='A' && ch<='Z') || (ch>='0' && ch<='9');
}
```

## 判断子序列 leetcode.392

判断字符串s是否是字符串t的子序列(字符按顺序出现即可,不一定连续)

思路: 双指针, 长度提取成变量可以优化速度

```java
public boolean isSubsequence(String s, String t) {
    int si=0,ti=0;
    int sLen = s.length(), tLen = t.length();
    while(si<sLen && ti<tLen){
        if(t.charAt(ti) == s.charAt(si)) si++;
        ti++;
    }
    return si==sLen;
}
```

## 输入有序数组的两数之和

输入数组升序, 求nums[i] + nums[j] < target

要求i<j

```java
public int[] twoSum(int[] numbers, int target) {
    int len = numbers.length;
    int j = len-1;
    int i = 0;
    // 两个指针向中间移动
    while(i<j){
        int sum = numbers[i] + numbers[j];
        // 结果比预期大了,下一个就要小一点,则j减小;
        if(sum>target){j--;}
        // 结果比预期小了,下一个就要大一点
        else if(sum<target){i++;}
        else{
            int[] result = {i+1,j+1};
            return result;
        }
    }
    return null;
}
```

# 2023/10/16

## 一最多的行 leetcode.2643

给定一个二维数组, 求每一行一的个数,如果多行个数一样返回行号最小的

```java
public int[] rowAndMaximumOnes(int[][] mat) {
    int maxCount = Integer.MIN_VALUE;
    int maxIndex = 0;
    for(int i=0;i<mat.length;i++){
        int count=0;
        for(int j=0;j<mat[0].length;j++){
            if(mat[i][j]==1){
                count++;
            }
        }
        // 因为行号递增,相等的时候不更新即可
        if(count>maxCount){
            maxCount = count;
            maxIndex = i;
        }
    }
    int[] r = {maxIndex, maxCount};
    return r;
}
```

## 可整除性得分最大的整数 leetcode.2644

nums中的数对divisors[i]进行取模运算,结果为0的个数为可整除性, 取最大的,若两个数可整除性相等取最小的

```java
public int maxDivScore(int[] nums, int[] divisors) {
    int maxCount = Integer.MIN_VALUE;
    int maxValue = 0;
    // nums的某一位%divisors的某一位 = 0
    for(int i=0;i<divisors.length;i++){
        // 要找count最大的
        int count = 0;
        for(int j=0;j<nums.length;j++){
            if(nums[j]%divisors[i] == 0) count++;
        }
        // 相等时新数小才更新
        if(count>maxCount || (count == maxCount && divisors[i]<maxValue)){
            maxCount = count;
            maxValue = divisors[i];
        }
    }
    return maxValue;
}
```

## 盛最多水的容器 leetcode.11

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：**你不能倾斜容器。

 

**示例 1：**

![img](%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98.assets/question_11.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

思路: 双指针首尾开始遍历, 面积取决于短板和底边

向内移动任何一个板,底边都可能变小
向内移动长板,短板不变或变小,面积一定变小
向内移动短板,短板可能变长,面积可能变大

```java
public int maxArea(int[] height) {
    // max(j-i*min(height[i],height[j]))
    int i=0, j=height.length-1;
    // 向内移动任何一个板,底边都可能变小
    // 向内移动长板,短板不变或变小,面积一定变小
    // 向内移动短板,短板可能变长,面积可能变大
    int maxS = Integer.MIN_VALUE;
    while(i<j){
        int s = (j-i)*Math.min(height[i], height[j]);
        if(s>maxS){
            maxS = s;
        }
        if(height[i]<height[j]){
            i++;
        }else{
            j--;
        }
    }
    return maxS;
}
```

# 2023/10/17

## 三数之和 leetcode.15

给你一个数组，判断是否存在三元组之和等于0，三元组不能重复

思路：先排序，然后遍历一个元素，剩下两个元素用双指针缩小检查范围

```java
import java.util.AbstractList;
class Solution {
    private List<List<Integer>> res;
    public List<List<Integer>> threeSum(int[] nums) {
        return new AbstractList<List<Integer>>( ) {
            @Override
            public List<Integer> get(int index) {
                init();
                return res.get(index);
            }

            @Override
            public int size() {
                init();
                return res.size();
            }

            private void init(){
                if(res!=null) return;
                // 对数组进行排序
                Arrays.sort(nums);
                List<List<Integer>> result = new ArrayList<>();
                // 遍历每一个数字
                int n = nums.length;
                for(int i=0;i<n-1;i++){
                    if(nums[i] > 0) break;
                    // 当前元素和上一个一致, 跳过
                    if(i>0 && nums[i-1] == nums[i]) continue;
                    int left = i+1;
                    int right = n-1;
                    while(left<right){
                        int sum = nums[i] + nums[left] + nums[right];
                        if(sum == 0){
                            result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                            // 去除重复值
                            while(left < right && nums[left] == nums[left+1]) left++;
                            while(left < right && nums[right] == nums[right-1]) right--;
                            left++;
                            right--;
                        }else if(sum > 0){
                            right--;
                        }else{
                            left++;
                        }
                    }
                }
                res = result;
            }
        };
    }
}
```

## 长度最小的子数组 leetcode.209

从大数组中找出和大于等于target的连续子数组,要找出长度最小的来

```java
public int minSubArrayLen(int target, int[] nums) {
    // 长度最小的子数组
    int i=0,j=0;
    // 记录数组的最短长度
    int minLen = Integer.MAX_VALUE;
    // 记录窗口内数字的和
    int sum = 0;
    // 始终遍历
    while(j<nums.length){
        // 右指针每次移动一格
        sum += nums[j++];
        // 如果窗口内之和大于目标,则左指针移动,直到小于
        while(sum>=target){
            if(j-i < minLen) minLen = j-i;
            sum -= nums[i++];
        }
    }
    // 如果长度没更新说明没有合适的,则设置为0
    if(minLen == Integer.MAX_VALUE) return 0;
    return minLen;
}
```

## 无重复字符的最长子串 leetcode.3

返回这个子串的长度

思路: 用哈希表记录字符串中每个字符最后出现的位置,遍历字符串,遇到一个重复的字符则将左指针移动

```java
public int lengthOfLongestSubstring(String s) {
    int n = s.length();
    if(n<=1) return n;
    int left=0,right=0;
    int max = 0;
    Map<Character, Integer> mem = new HashMap();
    while(right<n){
        char c = s.charAt(right);
        if(mem.containsKey(c)){
            // 记忆中存在当前字符,且当前字符再左指针右边
            left = Math.max(left, mem.get(c)+1);
        }
        // 更新当前字符最后出现的位置
        mem.put(c,right);
        // 更新最大长度
        max = Math.max(max, right-left+1);
        right++;
    }
    return max;
}
```


## 1.单例模式

### 概念

单例模式是指一个类在程序中**只存在一个实例**（实例对象），并提供一个**全局访问点**（通常是静态方法）

### 优点

全局控制：因为只有一个实例，所以方便对他进行全局控制

节省资源：省去了多次创建对象的开销

支持懒加载：懒汉式单例模式可以在首次调用时再加载，节省资源

### 使用场景

资源共享：多模块共享一个资源，比如配置管理器，数据库连接池等

只需要一个实例：例如缓存控制，线程池

懒加载：对象创建耗费资源，使用单例模式进行懒加载

举例：Java的Runtime类，Spring的ApplicationContext类都是单例的

### 必要条件

私有的构造函数：防止通过其他方式获取实例

私有的静态实例属性：用一个静态属性存储实例对象

公开的静态访问点：通过这个访问点可以获取到静态属性存储的实例对象

### 示例

饿汉式：

```java
class Car{
    // 直接创建
    private static final Car car = new Car();
    // 私有的构造器
    private Car(){}
    
	// 公有的全局访问点
    public static Car getInstance(){
        return car;
    }
    
    // 业务代码
    private Map<String,Integer> map = new HashMap<>();
    
    public void put(String name, int count){
        map.put(name,count);
    }
    
    public int get(String name){
        return map.get(name);
    }
}
```

懒汉式:

```java
class Car{
    // 私有的静态实例属性
    private static Car car;
    // 私有构造器
    private Car(){}
	// 全局访问点
    public static Car getInstance(){
        if(Car.car==null) car = new Car();
        return car;
    }
    
    private Map<String,Integer> map = new HashMap<>();
    
    public void put(String name, int count){
        map.put(name,count);
    }
    
    public int get(String name){
        return map.get(name);
    }
}
```

双重加锁的懒汉式:

```java
class Car{
    private volatile static Car car;
    private Car(){}

    public static Car getInstance(){
        if(Car.car==null){
            synchronized (Car.class){
                if(Car.car==null) car = new Car();
            }
        }
        return car;
    }
}
```

### 双重加锁的懒汉式

volatile禁止指令重排

synchronized锁类对象，保证实例真的为空再创建

## 2.工厂模式

### 简单工厂模式

用一个多分支工厂方法返回不同的产品

```java
public static 产品 create(String type){
    if(type=="产品1"){
        return new 产品1();
    }else if(type=="产品2"){
        return new 产品2();
    }
}
```

![image-20240322161902830](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20240322161902830.png)

抽象产品: 定义产品的行为，一般为接口

具体产品：实现了抽象产品接口的具体类，实现对应的方法

工厂类：负责创建产品，通过传入的参数不同获取不同的产品

缺点：添加新的产品需要修改工厂类代码

### 工厂方法模式

引入抽象工厂和具体工厂的概念

![image-20240322171254605](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20240322171254605.png)

抽象工厂: 接口，定义工厂类的行为

具体工厂：不同产品对应不同的具体工厂，负责生产对应的产品

优点：添加新的产品只需要实现新的工厂类即可，不会改变原有的代码结构，符合开闭原则

### 示例

```java
// 抽象产品
interface Block{
    void say();
}

// 抽象工厂
interface BlockFactory{
    Block createBlock();
}

// 产品类
class CircleBlock implements Block{
    public void say(){
        System.out.println("Circle Block");
    }
}

// 产品类
class SquareBlock implements Block{
    public void say(){
        System.out.println("Square Block");
    }
}

// 工厂类
class CircleFactory implements BlockFactory{
    public Block createBlock(){
        return new CircleBlock();
    }
}

// 工厂类
class SquareFactory implements BlockFactory{
    public Block createBlock(){
        return new SquareBlock();
    }
}
```



### 工厂模式应用场景

创建对象需要复杂逻辑，这些逻辑在不同子类中有不同的实现

例子：

1. Spring中的Bean工厂，通过配置文件或注解，Spring可以动态创建对象
2. JDBC中的Connection工厂，DriverManager使用工厂方法模式来创建数据库连接，不同的数据库驱动实现对应的工厂类来创建自己的连接。
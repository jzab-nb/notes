## JAVA基础

### JAVA值传递

#### 形参实参

形参：方法体中定义的参数，用来指定接受的参数的类型，无需有值

实参：调用方法时，给方法传递的参数，需要有实际的值

#### 值传递，引用传递

值传递：传递参数时传递的是原始数据的拷贝值，方法内对参数的修改不会影响外面的值

引用传递：传递的是原始数据的地址，方法内对参数的修改会修改到原始的值

**注意**: 在JAVA中只存在值传递，不存在引用传递，若传递基本数据类型，会拷贝一份数据，若传递引用类型，会拷贝一份引用的地址

#### 为什么JAVA不使用引用传递

1. 考虑到安全性，方法是被封装好的，若使用引用传递，调用者的数据可能会被方法修改
2. JAVA设计者在设计之初就看到了C和C++的弊端，去掉了这些特性，减少学习成本和不确定性

### 序列化

#### 什么是序列化

序列化：将JAVA中的对象转化成二进制流数据

反序列化：二进制流数据转化成JAVA对象

#### 序列化的常用场景

网络传输(RPC调用)、存数据库(redis)、存文件(如py的泡菜方法)、存内存

#### 序列化所在层

若使用OSI七层模型，序列化在表示层

若使用TCP/IP模型，序列化在应用层

#### 常用序列化协议

Protobuf(谷歌推出，跨语言)、ProtoStuff(上一个的增强版)、Hessian、Kryo、

JSON和XML也可以用于序列化，但效率较低，不常用

#### JDK自带序列化

实现java.io.Serializable接口即可实现JDK自带的序列化

```java
public class LoginUserVo implements Serializable {
    @Serial
    private static final long serialVersionUID = 1L;、
    // 不被序列化的字段
    transient int noSerial;
}
```

**关于序列化版本字段**：需要序列化的类通常要有一个名为serialVersionUID的静态属性，可以用@Serial注解指定他。虽然是静态属性，但他也会被序列化，这是JDK的特殊处理，这个属性用于判断序列化对象的类型

**哪些字段不会被序列化**：使用transient修饰的属性以及静态属性不会被序列化

**缺点**: 不支持跨语言，性能差，安全性低

### 泛型

泛型是JDK1.5引入的新特性，用于在使用时指定类型，泛型一般有三种使用方式：泛型类、泛型方法、泛型接口

泛型的主要作用:

- 编译期间进行类型检查
- 不需要强制类型转换
- 可限定类型到自定义类型而不是Object

泛型的缺陷:

- 不能实例化T类型的变量。
- 泛型参数不能是基本类型。因为基本类型不是Object的子类，应该用对应的包装类代替。
- 不能实例化泛型类型的数组
- 不能使用instance of 和 getClass进行类型判断
- 不能实现两个不同泛型参数的同一接口，擦除后桥方法会冲突
- 不能使用static修饰泛型变量

#### 泛型类

```java
public class User<T>{
    
}

// 实例化泛型类
User<String> u = new User<String>();
```

#### 泛型接口

```java
public interface UserService<T>{
    
}

// 实现泛型接口不指定类型
public class A<T> implements UserService<T>{
    
}

// 实现泛型接口指定类型
public class A<T> implements UserService<String>{
    
}
```

#### 泛型方法

```java
public static <E> void print(E arg){
    
}
```

#### 会用到泛型的场景

- 自定义通用返回结果类
- 构建通用的排序工具类

#### 泛型擦除

> 为了不创建新类型、减少编译器开销同时兼容旧版JDK，在编译期间，所有的泛型类型会被擦除掉，若有限定父类型，则变为父类型，若无则变为Object，但是编译器会将泛型信息保存起来，所以通过反射或部分反编译工具可以还原出泛型类型。

由于泛型擦除，通过反射向Integer类型的列表中添加String类型的变量是成立的

由于泛型擦除，两个不同泛型类型的方法重载是不被允许的，例如下面的就会报错

```java
public void print(List<String> arg);
public void print(List<Integer> arg);
```

#### 桥方法

> 子类实现泛型接口或继承泛型类时指定类型，在泛型擦除后，子类中并没有实现重写Object类型的方法，这时编译器会添加一个桥方法来保证多态

```java
class Node<T> {
    public T data;
    public Node(T data) { this.data = data; }
    public void setData(T data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}
class MyNode extends Node<Integer> {
    public MyNode(Integer data) { super(data); }
    // Node<T> 泛型擦除后为 setData(Object data)，而子类 MyNode 中并没有重写该方法，所以编译器会加入该桥方法保证多态
    public void setData(Object data) {
        setData((Integer) data);
    }
    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```


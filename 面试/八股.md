## JAVA基础

### JAVA值传递

#### 形参实参

形参：方法体中定义的参数，用来指定接受的参数的类型，无需有值

实参：调用方法时，给方法传递的参数，需要有实际的值

#### 值传递，引用传递

值传递：传递参数时传递的是原始数据的拷贝值，方法内对参数的修改不会影响外面的值

引用传递：传递的是原始数据的地址，方法内对参数的修改会修改到原始的值

**注意**: 在JAVA中只存在值传递，不存在引用传递，若传递基本数据类型，会拷贝一份数据，若传递引用类型，会拷贝一份引用的地址

#### 为什么JAVA不使用引用传递

1. 考虑到安全性，方法是被封装好的，若使用引用传递，调用者的数据可能会被方法修改
2. JAVA设计者在设计之初就看到了C和C++的弊端，去掉了这些特性，减少学习成本和不确定性

### 序列化

#### 什么是序列化

序列化：将JAVA中的对象转化成二进制流数据

反序列化：二进制流数据转化成JAVA对象

#### 序列化的常用场景

网络传输(RPC调用)、存数据库(redis)、存文件(如py的泡菜方法)、存内存

#### 序列化所在层

若使用OSI七层模型，序列化在表示层

若使用TCP/IP模型，序列化在应用层

#### 常用序列化协议

Protobuf(谷歌推出，跨语言)、ProtoStuff(上一个的增强版)、Hessian、Kryo、

JSON和XML也可以用于序列化，但效率较低，不常用

#### JDK自带序列化

实现java.io.Serializable接口即可实现JDK自带的序列化

```java
public class LoginUserVo implements Serializable {
    @Serial
    private static final long serialVersionUID = 1L;、
    // 不被序列化的字段
    transient int noSerial;
}
```

**关于序列化版本字段**：需要序列化的类通常要有一个名为serialVersionUID的静态属性，可以用@Serial注解指定他。虽然是静态属性，但他也会被序列化，这是JDK的特殊处理，这个属性用于判断序列化对象的类型

**哪些字段不会被序列化**：使用transient修饰的属性以及静态属性不会被序列化

**缺点**: 不支持跨语言，性能差，安全性低
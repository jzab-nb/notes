## Java基础

### 01.Java中的序列化和反序列化是什么

我的回答:

序列化就是将Java对象转换成可以在网络中传输的字节流

反序列化就是将这个字节流转换为Java对象

JDK自带的序列化性能和安全性都不足,可以选择使用ProtoBuf等第三方的序列化工具

序列化的类需要实现Serizable接口这个接口没有方法,只起标记作用

序列化的类可以通过一个SerizeId字段,来标记类的版本,保证序列化和反序列化的是同一个版本的类

对于不想被序列化的字段可以使用@Trasint注解来进行标记

官方回答补充：

1. 不只是在网络中传输，也包括持久化缓存等场景

2. transient是关键字不是注解
3. Serializable serialVersionUID拼写,serialVersionUID是private static final long类型
4. 序列化不包含静态变量,序列化的是实例而不是类

### 02.什么是Java中的不可变类

我的回答:

1. 这个类被final修饰
2. 这个类的属性都是私有且被final修饰的,并且没有暴露可以修改属性的方法

不可变类的优点是天生线程安全，可以在多线程环境中随意使用，而且可以进行缓存

Java的String就是一个不可变类

官方回答补充:

1. 属性不仅要私有,还要被final修饰
2. 所有字段通过构造函数初始化
3. 如果成员是引用类型,要保证被引用的对象也不可变,例如get时返回拷贝而不是原值
4. 其他的不可变类: Integer,BigDecimal,LocalDate
5. 不可变类的缺点: 每次改变都要拷贝新对象,性能差

### 03.Java中的Exception和Error的区别

我的回答：

Exception一般是一些可以提前预知的异常，应该被try catch捕获进行处理或者抛出

Error一般是一些不可预知的错误，会导致程序崩溃，不应该进行捕获处理。因为出现这种错误程序一般无法继续执行。

官方回答补充：

1. Exception包含CheckedException和UncheckedException两种，CheckedException在编译时需要显式的处理，否则无法编译通过。UncheckedException则不需要显式的处理
2. CheckedException的子类有：IOException（输入输出异常）
3. UncheckedException的子类有：NullPointerException，IllegalArgumentException等（空指针，参数异常）
4. Error的子类有: OutOfMemoryError,StackOverFlowError(内存耗尽,栈溢出)
5. 异常处理的注意点:
   1. 捕获具体的异常而不是父类
   2. 捕获之后一定要有日志输出
   3. 异常不要延迟处理,发生了立即处理
   4. 只在需要的地方try,try的范围尽可能的小
   5. 不要用try来控制程序流程,能用if条件判断的用if
   6. 不要再finally里面return

### 04.Java的优势

我的回答：

1. 面向对象，具有完整的面向对象机制，可维护性和可扩展性好
2. 生态良好，有很多优秀的开源框架和开发者，社区生态好
3. 跨平台，基于JVM和字节码实现了一次编译多处执行，一套代码可以在多个平台运行
4. 垃圾回收机制，这个机制可以让java程序员不需要手动管理内存。

### 05.Java中的多态

我的回答：

多态是三大面向对象特性的一种，多态可以细分为两种：编译时多态和运行时多态

运行时多态是通过方法的重写实现，子类继承父类并重写父类的方法，调用时使用父类的引用进行调用

编译时多态通过方法的重载实现，相同的方法名使用不同的参数，让同一功能的不同实现可以共存。调用时通过传入的参数判断调用哪一个方法。

多态的好处是提高了代码的通用性。

官方回答补充:

1. 编译时多态是重载,运行时多态是重写
2. 优点: 让程序员可以面向抽象编程而不是面向具体的实现。
3. 父类的引用指向子类的对象

### 06.参数是引用传递还是值传递

我的回答:

JAVA只有值传递没有引用传递，对于基本类型，直接传递值的拷贝，对于引用类型，传递的是引用地址的拷贝

### 07.为什么不支持多继承

我的回答：

防止出现菱形继承的问题，一个类继承的A类和B类，AB类又分别继承了X类，调用时不知道该调用A的还是B的，出现冲突。

官方回答补充：

接口是可以多实现的，因为子类必须重写接口的方法，接口内可能有默认实现，如果多个接口有相同的默认方法的话，那么实现接口的子类就必须重写这个方法

### 08.面向对象和面向过程的区别

我的回答：

面向对象编程围绕着类和对象进行，设计的时候思考的角度也是类和对象的角度

面向过程编程侧重于描述一个事情执行的步骤，先干什么后干什么

官方回答补充：

1. 思维方式: 面向对象关注类和对象的关系，面向过程关注逻辑的执行顺序
2. 数据和行为的关系：面向对象数据和行为都封装在对象内部，面向过程数据和函数是分开的
3. 可扩展性：面向对象有继承和多态这种特性，扩展性较好，面向过程要扩展大部分时候需要修改已有的代码，复用性也较低
4. 适用场景：面向对象适用于复杂的业务场景，面向过程适用于快速开发简单的业务

### 09.方法的重载和重写的区别

我的回答：

方法的重载是一个类内部的同名方法，使用不同的参数

方法重写是子类继承父类，然后重写父类的方法，方法名和参数是和父类相同的

方法重载主要用于实现一个功能的不同实现方式

方法重写是子类要对父类的功能进行拓展或修改时使用

官方回答补充：

1. 重载的参数顺序不同也算重写
2. 重载可以有不同的返回值
3. 子类的重写不能抛出比父类更多更大的异常,只能抛出和父类相同的异常或者父类异常的子类
4. 子类的重写的修饰符不能比父类的更严格,只能相对更宽泛

### 10.什么是内部类

我的回答：

内部类就是定义在一个类的内部的类，分为三种：普通内部类，匿名内部类，静态内部类

官方回答补充：

内部类分四种:

1. 成员内部类，在类中直接定义，可以使用外部类的属性和方法（包括私有的）
2. 静态内部类，在类中定义时添加static关键字，不能使用外部类的非静态属性和方法，相当于一个顶级类
3. 局部内部类，在方法内部定义，只在当前方法内可用
4. 匿名内部类，没有类名的内部类，只能使用一次，一般用于实现接口或者抽象类，得到的实例用于进行回调等操作。

### 11.JDK8有哪些新特性

我的回答:

1. Stream流
2. lambda表达式

官方回答补充:

1. 引入了新的日期类
2. 引入了接口的默认方法和接口的静态方法
3. 引入了Optional类: 用于优雅的处理可能的空指针问题
4. 元空间替代永久代
5. 新增了CompletableFuture、StampedLock等并发实现类: CompletableFuture简化异步任务的编写
6. 修改了HashMap和ConcurrentHashMap的实现

### 12.String,StringBuffer,StringBuilder的区别

我的回答:

1. String是不可变的,另外两个是可变的
2. StringBuffer适用于多线程的场景,Builder适用于单线程的场景,Buffer性能不如Builder

官方回答补充:

1. Buffer之所以安全是因为所有的方法都使用了synchronized关键字，都继承自AbstractStringBuilder底层都是char数组

### 13.StringBuilder的实现原理

我的回答:

不知道

官方回答补充:

1. 底层使用char数组实现,java9之后改为byte数组
2. 通过append,insert等方法操作内部的数组,而不是直接产生新对象
3. 容量不足时会进行二倍扩容
4. 初始容量16

### 14.包装类和基本类型的区别

我的回答:

1. 包装类时引用类型,基本类不是
2. 包装类作为属性时默认值是null,基本类型默认值是0或者false等
3. 包装类全都存在堆空间中,基本类型要么在栈空间,要么和对象一块存在堆空间中
4. 有些包装类有缓存机制,基本类型没有缓存

### 15.接口和抽象类的区别

我的回答:

1. 接口全都是抽象方法,抽象类可以有普通方法